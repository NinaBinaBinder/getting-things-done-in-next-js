<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Getting Things Done in Next.js</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li><li class="chapter-item expanded "><a href="chapter1/index.html"><strong aria-hidden="true">1.</strong> A Brief Introduction to JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/01-hello-world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="chapter1/02-primitive-data-types.html"><strong aria-hidden="true">1.2.</strong> Primitive Data Types</a></li><li class="chapter-item expanded "><a href="chapter1/03-arrays-and-objects.html"><strong aria-hidden="true">1.3.</strong> Arrays and Objects</a></li><li class="chapter-item expanded "><a href="chapter1/04-control-flow.html"><strong aria-hidden="true">1.4.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="chapter1/05-functions.html"><strong aria-hidden="true">1.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter1/06-functional-thinking.html"><strong aria-hidden="true">1.6.</strong> Functional Thinking</a></li><li class="chapter-item expanded "><a href="chapter1/07-asynchronous-programming.html"><strong aria-hidden="true">1.7.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="chapter1/08-modules.html"><strong aria-hidden="true">1.8.</strong> Modules</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/index.html"><strong aria-hidden="true">2.</strong> Leveling Up with TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/01-why-typescript.html"><strong aria-hidden="true">2.1.</strong> Why TypeScript?</a></li><li class="chapter-item expanded "><a href="chapter2/02-basic-types.html"><strong aria-hidden="true">2.2.</strong> Basic Types</a></li><li class="chapter-item expanded "><a href="chapter2/03-annotating-functions.html"><strong aria-hidden="true">2.3.</strong> Annotating Functions</a></li><li class="chapter-item expanded "><a href="chapter2/04-union-types.html"><strong aria-hidden="true">2.4.</strong> Union Types</a></li><li class="chapter-item expanded "><a href="chapter2/05-generics.html"><strong aria-hidden="true">2.5.</strong> Generics</a></li><li class="chapter-item expanded "><a href="chapter2/06-the-keyof-and-typeof-operators.html"><strong aria-hidden="true">2.6.</strong> The keyof and typeof Type Operators</a></li></ol></li><li class="chapter-item expanded "><a href="chapter3/index.html"><strong aria-hidden="true">3.</strong> A Vanilla Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter3/01-hypertext-markup-language.html"><strong aria-hidden="true">3.1.</strong> Hypertext Markup Language</a></li><li class="chapter-item expanded "><a href="chapter3/02-marking-up-text.html"><strong aria-hidden="true">3.2.</strong> Marking Up Text</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-things-done-in-nextjs"><a class="header" href="#getting-things-done-in-nextjs">Getting Things Done In Next.js</a></h1>
<p><em>by Mikhail Berkov</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="text-align: right"> <i>No one reads introductions anyway.<br> — Sun Tzu</i></div>
<p>Long gone are the times when JavaScript was just a scripting language to add simple interactive behaviour to websites. The ECMAScript 2015 standard significantly improved the usability of the language. Excellent UI libraries like React allow you to write straightforward declarative code which massively simplifies building user interfaces. Thanks to Node.js you can write JavaScript on the server. Next.js empowers you to write complex APIs very quickly and PostgreSQL provides a relational database that fits right in with the other tools. The Next.js stack therefore allows you to quickly develop complex applications using just one language - JavaScript (with optional type hints via TypeScript).</p>
<p>This book serves as an introduction to the Next.js stack. However you don't learn software development by <em>just</em> reading books, you learn it by creating projects. We will therefore not bombard you with useless language trivia for hundreds of pages. If you care about that, go read the standard - it's <em>pretty comprehensive</em>. Instead we will create a real software project - an application for managing tasks called <strong>easy-opus</strong> (get it?). We will begin with nothing more than an empty project directory and the <em>will to learn</em>. We will end with a useful piece of software that allows us to create tasks, assign tasks to different users, update their statuses and much more.</p>
<p>This book is therefore <em>inherently practical</em> - unlike some other literature we will not dwell much on theoretical considerations. On the other hand, purely practical concerns are first-class citizens here (for example there is an entire chapter devoted to hosting your application). This doesn't mean that <em>theory bad, practice good</em>. It simply means that the approach for <em>this particular book</em> is heavily geared towards completing a real software project.</p>
<p>This book is therefore also <em>not</em> about becoming <em>yet another JavaScript guru</em>™ (there are already too many of them). It's about writing a useful product. It is fundamentally about <strong>getting things done</strong>. The Next.js stack is really just a tool we use to get things done.</p>
<p>This book is suitable for both beginners who want to pick up their first tech stack as well as for seasoned software developers looking to expand their knowledge.</p>
<p>This book is intended to be a standalone resource. While there are resources for further reading in each section, these are merely pointers if you want to dive deeper into a certain topic. You <em>don't have</em> to read them and you should be able to understand everything without reading them. In fact, if you are hard stuck in a certain place, this probably represents a failure on our part. Maybe we didn't explain an important concept well enough (or at all!). Don't hesitate to write an email to <code>uhasker@protonmail.com</code> or to create an issue at <code>https://github.com/uhasker/getting-things-done-in-next-js</code> explaining your problem.</p>
<p><em>Happy hacking</em></p>
<p><em>Mikhail Berkov</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>I sincerely thank the following people for <strong>major</strong> contributions to this book:</p>
<ul>
<li>Jannis Morgenstern</li>
<li>Alexander Berkov</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-a-brief-introduction-to-javascript"><a class="header" href="#chapter-1-a-brief-introduction-to-javascript">Chapter 1: A Brief Introduction to JavaScript</a></h1>
<div style="text-align: right"> <i> JavaScript has beauty, but not everyone sees it. <br> - Confucius </i> </div>
<p>First we will need to go through the basics of the JavaScript language that we will use pretty much everywhere throughout this book. After all the Next.js stack is built on top of it.</p>
<p>You will setup your runtime, learn about variables, data types, operators and control flow. You will also learn how to write functions and how to think <em>functionally</em>. Thinking <em>functionally</em> will make you a better software developer and a better person. Isn't that great?</p>
<p>Let's dive right in!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<div style="text-align: right"> <i> A journey of a thousand miles begins with a single "Hello, world!" program. <br> — Ancient Chinese proverb </i> </div>
<h3 id="runtime-environments"><a class="header" href="#runtime-environments">Runtime Environments</a></h3>
<p>Contrary to popular belief, code sadly doesn't run on pixie dust, magic spells, and unicorn tears.
Instead, it runs on something called a <strong>runtime environment</strong> (also referred to as <em>runtime system</em> or just <em>runtime</em>).
Put simply, a runtime is a program capable of executing code written in some programming language.
It <em>provides the environment in which programs can run</em>.
In order to execute all the <em>awesome</em> JavaScript code we are about to write, we therefore need a runtime first.</p>
<p>There are two runtimes capable of executing JavaScript code, which are relevant to this book - the browser and Node.js.
The browser as well as the Node.js console have <strong>REPL</strong> (read-eval-print-loop) capabilities.
This means you can directly type some code into the console and execute it.
REPLs are very nice, because they allow you to quickly test what you just learned.
Additionally, both runtimes can execute a file containing JavaScript code.
This is how we will usually utilize the runtimes - we write a <strong>script</strong> (a file containing JavaScript code) and tell our runtime to execute it.</p>
<blockquote>
<p>As projects grow larger, we will usually be dealing with multiple files at the same time.
We will talk about this in the &quot;Modules&quot; section of this chapter.</p>
</blockquote>
<p>Every runtime environment comes with a <strong>console</strong>.
This isn't a retro gaming console; rather, it's a special part of the runtime where you can input commands and see the results of your code in real-time.
Think of it as a conversation between you and the program - you tell it what to do (input commands) and it responds by executing those commands and showing you what happened (output).</p>
<p>In this section we will set up the browser and Node.js runtimes.
Then we will print &quot;Hello, world!&quot; to both the browser console and the Node.js console to test that our setup functions as anticipated.</p>
<h3 id="the-browser-environment"><a class="header" href="#the-browser-environment">The Browser Environment</a></h3>
<p>Open a browser, and open its console.
How you do this will depend on the browser.</p>
<p>If you are using <em>Firefox</em> the shortcut for opening the console is <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd> on Ubuntu/Debian and <kbd>Cmd</kbd> + <kbd>Option</kbd> + <kbd>K</kbd> on a Mac.
If you are using <em>Chrome</em> or <em>Microsoft Edge</em> the shortcut is <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd> on Ubuntu/Debian and <kbd>Cmd</kbd> + <kbd>Option</kbd> + <kbd>J</kbd> on a Mac.
If you are using <em>Safari</em> on a Mac, you will need to enable the develop menu first by going to <code>Settings &gt; Advanced</code> and ticking the box <code>Show Develop menu in menu bar</code>. Then you can open the console using <kbd>Cmd</kbd> + <kbd>Option</kbd> + <kbd>K</kbd>.</p>
<blockquote>
<p>If you are using Internet Explorer, please navigate to <code>google.com</code> and search for &quot;Firefox&quot; to install a <em>real</em> browser.
This line was originally intended to be a funny joke, but on June 15, 2022 Microsoft ended support for Internet Explorer, so it's not even a joke anymore.
We personally recommend Firefox, but Chrome, Microsoft Edge or Safari are also fine choices.</p>
</blockquote>
<p>This is approximately how the browser console will look on Firefox:</p>
<p><img src="chapter1/images/browser-console.png" alt="" /></p>
<blockquote>
<p>Note that if you see a bunch of scary error or warning messages upon opening the console, <em>don't panic</em> (this is also good life advice in general).
Most of these will probably come from various extensions you might have installed or the web page you are currently viewing.
You can simply delete these messages, as we don't care about them.</p>
</blockquote>
<p>Let us print something using the <code>console.log</code> method. Type the following into the browser console:</p>
<pre><code class="language-js">console.log('Hello, world!');
</code></pre>
<p>Now hit <kbd>Return</kbd> (you may also know this as <kbd>Enter</kbd> or simply <kbd>⏎</kbd>).
You will see the output &quot;Hello, world!&quot; in the console:</p>
<p><img src="chapter1/images/browser-console-log.png" alt="" /></p>
<blockquote>
<p>Ignore the &quot;undefined&quot; for now.</p>
</blockquote>
<p>Hooray, we printed something to the browser console!
This is the point at which you go tell everyone that you are now a <em>programmer</em>™.</p>
<h3 id="executing-javascript-from-an-html-file"><a class="header" href="#executing-javascript-from-an-html-file">Executing JavaScript from an HTML File</a></h3>
<p>As we already mentioned, instead of executing JavaScript in the browser console directly, we can (and often will) execute it from a JavaScript file.
Since we're on the browser, we will need to create two files - an HTML file and a JavaScript file.</p>
<p>HTML is short for <em>HyperText Markup Language</em> and is the standard markup language for documents that should be displayed in a browser.
We will cover HTML in chapter 2, for now we just want to get a quick glimpse at it.</p>
<p>Create a new HTML file.
We will call it <em>hello.html</em>; however you can name it whatever you want.
The filename should have an <em>html</em> extension though.</p>
<p>Open the HTML file in any text editor (we recommend you use <a href="https://code.visualstudio.com">Visual Studio Code</a>) and add the following text to the file:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Don't forget to save the file!</p>
<p>Now create another file called <em>hello.js</em> in the same directory as <em>hello.html</em> with the following content:</p>
<pre><code class="language-js">console.log('Hello, world');
</code></pre>
<blockquote>
<p>Note the semicolon after the <code>console.log</code>.
It terminates the <code>console.log</code> statement.
The semicolon is not technically required here.
Indeed there are many JavaScript programmers who don't write semicolons.
However, to avoid a bunch of pitfalls, we will use semicolons throughout this book and therefore we want you to get used to them as soon as possible.</p>
</blockquote>
<p>Now open this file in your browser by simply double-clicking the file.
After opening this file in your browser, open the console again. You should see <code>Hello, world!</code> printed there.</p>
<p>Congratulations, you wrote your first script!</p>
<h3 id="working-with-a-command-line"><a class="header" href="#working-with-a-command-line">Working With a Command Line</a></h3>
<p>Now that we know how to use the browser runtime, we will move on to Node.js.
However, before we can do that, we will need to learn how to interact with the <strong>command-line interface</strong> (also called command line, command prompt or CLI).
A command line allows you to execute various tasks called commands.</p>
<p>If you're on Ubuntu, you can open the command line by pressing <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd>.</p>
<p>On a Mac, you can open the command line by pressing <kbd>Cmd</kbd> + <kbd>Space</kbd> to open <em>search</em>, typing <em>terminal</em> and then hitting <kbd>Return</kbd>.</p>
<p>Now that you've opened a CLI, you can type a command and hit <kbd>Return</kbd> to execute it.
Try executing this command for starters:</p>
<pre><code class="language-sh">echo 'Hello, world!'
</code></pre>
<blockquote>
<p>Generally whenever we tell you to execute a command you need to type it in the CLI and hit <kbd>Return</kbd>.</p>
</blockquote>
<h3 id="the-nodejs-runtime"><a class="header" href="#the-nodejs-runtime">The Node.js Runtime</a></h3>
<p>For a long time, JavaScript was mostly used inside the browser runtime environment by programmers.
However in 2009 Node.js came along and changed that by allowing programmers to easily run JavaScript outside the browser.</p>
<p>Node.js will probably not be installed on your machine, so let's fix that.
First, we will install the <strong>Fast Node Manager</strong> (<strong>fnm</strong> for short) which will allow us to manage Node.js versions in a simple and straightforward manner.</p>
<p>On Ubuntu/Debian you will need to run the following:</p>
<pre><code class="language-sh">curl -fsSL https://fnm.vercel.app/install | bash
source ~/.bashrc
</code></pre>
<p>On Mac you will need to run the following:</p>
<pre><code class="language-sh">curl -fsSL https://fnm.vercel.app/install | zsh
source ~/.zshrc
</code></pre>
<p>Check that <code>fnm</code> was successfully installed:</p>
<pre><code class="language-sh">fnm --version
</code></pre>
<p>Finally we will install Node.js (version 18):</p>
<pre><code class="language-sh">fnm install 18
</code></pre>
<p>And again verify that Node.js was successfully installed:</p>
<pre><code class="language-sh">node --version
</code></pre>
<p>The installation script also automatically installed the <strong>node package manager</strong> (<em>npm</em> for short) which will later become necessary for managing dependencies in our projects.
Verify that npm was installed as well:</p>
<pre><code class="language-sh">npm --version
</code></pre>
<p>Now that Node.js is installed, you can open a Node.js console by typing node in the command line.
Now let's again print &quot;Hello, world!&quot; using the <code>console.log</code> method.
Type the following into the Node.js console and hit <kbd>Return</kbd>:</p>
<pre><code class="language-js">console.log('Hello, world!');
</code></pre>
<p>You should see <code>&quot;Hello, world!&quot;</code> printed to the console.</p>
<h3 id="executing-a-file"><a class="header" href="#executing-a-file">Executing a File</a></h3>
<p>Before moving on, let's execute a JavaScript file in Node.js as well.
Create a file named <code>hello.js</code>.
Open the file in any text editor and add the following content to the file:</p>
<pre><code class="language-js">console.log('Hello, world!');
</code></pre>
<p>Again open a command line and <em>change the current directory location to the directory containing the JavaScript file</em>.
You can do so using the <em>cd</em> command. For example if <code>hello.js</code> is located at <code>/home/users/user</code> you would execute the following:</p>
<pre><code class="language-sh">cd /home/users/user
</code></pre>
<p>Now execute the JavaScript file by running:</p>
<pre><code class="language-sh">node hello.js
</code></pre>
<p>This should again print <code>&quot;Hello, world!&quot;</code>.</p>
<p>Note that for the remainder of chapter 1 you should follow along using the Node.js console as we will be discussing the language itself.
Nevertheless, as we begin writing the project in chapter 2, we will have to write JavaScript for the browser runtime environment on a regular basis.</p>
<h3 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements And Expressions</a></h3>
<p>Before we dive into JavaScript, you should know that programs are made of statements and expressions.</p>
<p>A <strong>statement</strong> is a syntactic unit responsible for executing some action.
A <strong>program</strong> is then essentially a sequence of statements which should be executed when running the program.
For example <code>console.log('Hello, world!')</code> is a statement which executes the action of printing &quot;Hello, world!&quot; to the console.</p>
<p>An <strong>expression</strong> is a syntactic unit that may be evaluated to get its value.
For example <code>2 + 2</code> would be an expression which would evaluate to <code>4</code>.
Note that since any expression also executes some action, any expression is therefore a statement.</p>
<p>You could put it this way: Statements in general are executed to make something happen, while expressions in specific are evaluated to produce a value.</p>
<blockquote>
<p>Note that other authors might define statements and expressions in a slightly different manner.
However we will stick to these definitions throughout the book.</p>
</blockquote>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Everything that is after a double slash on a line in JavaScript is a <strong>comment</strong>.
Comments are ignored by the runtime and therefore have no effect for the execution of your program:</p>
<pre><code class="language-js">// This is just a comment
// Comments have no effect
console.log('Hello, world!');
// Therefore this program is equivalent to the
// program from the previous chapter
</code></pre>
<p>We will heavily utilize comments throughout this book inside the code blocks to highlight important ideas.</p>
<blockquote>
<p>There is a lot of discussion on how much you should comment your programs.
We will return to this when discussing functions.
However one rule is that if your code is so terrible that it requires <em>extensive commentary</em> to explain its behavior or purpose, you should fix the code.
Just like a work of art, your code should stand on it's own merits.
Imagine <em>commenting</em> a work of art (oh, wait)...
However it is better to have terrible code and comments than have terrible code and no comments.</p>
</blockquote>
<p>We will also adopt the convention that if a comment is next to a line with a <code>console.log</code> statement, that comment shows the output that would be logged to the console if the code was run. For example:</p>
<pre><code class="language-js">console.log('Hello, world!'); // Hello, world!
</code></pre>
<p>This is the point where we tell you that while you are reading this book you should <em>absolutely follow along in some runtime</em> (probably Node.js, but a browser is fine too).
This is <em>very important</em>.
Go ahead and open a Node.js console <em>now</em>.</p>
<p>Come on, we'll wait...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p><em>Finally</em>.
Let's move on.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>You learned about the JavaScript browser runtime, Node.js and how to use the console of the various runtimes.
You learned how to execute code in a REPL as well as how to execute scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h2>
<div style="text-align: right"> <i> == is the equality operator <br> === is the one and true equality operator <br> ==== is the equality operator which transcends time and space <br> ===== is the equality operator which transcends all other equality operators <br> ====== is the equality operator which summons the UNSPEAKABLE DOOM h̷̳͓͝ě̵̞͂ ̵̮͍͊͋i̴͎͂s̵̗͒ ̷̘̤̓̅h̸͜͝ḙ̵̀r̶͈̆ȇ̶̗̱̍ ̸͕̾h̴̲̗̾̅e̷̟̋ả̶̬v̶̯́̐͜ẽ̸̛͔n̶̩̒͊ ̴̢̯̍ḣ̵̳̻e̴̙̒̓l̵͇̟̃p̶̘̑ ̷̠͛͝ŭ̴͇̯̕s̶̮͕̒ <br> — from "The Book of the Equality Operators and their Virtue" by Laozi </i> </div>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p>Whenever we write programs, we need to manipulate data.
This data needs to be stored somewhere and we need to be able to access it somehow.
We also need to deal with the fact that when we execute a program, the values we deal with are not predictable in advance.
For example we don't know which tasks a user might create.
Nevertheless, we must be able to access created tasks through a predictable name like <code>tasks</code> or <code>createdTasks</code>.</p>
<p>Therefore we need a way to put an <em>unpredictable</em> value in a &quot;box&quot; somewhere and refer to it using a <em>predictable</em> name.
This box is referred to as 'storage' and the predictable name as <em>symbolic name</em> in programming.</p>
<p>A <strong>variable</strong> is just that - a storage location containing a value which is referred to by a symbolic name.
This <em>sounds</em> really fancy, but it just means that there is a value somewhere in your storage and you can refer to that value using a symbolic name (even if the value itself is not predictable).</p>
<p>You can think of a variable as a labeled box in a storage room.
The box contains some stuff (the unpredictable value) which we can find later by looking for the label (the predictable symbolic name).</p>
<p>For example you could have a variable <code>age</code> which has the value <code>20</code> (we say that <code>age</code> is equal to <code>20</code>):</p>
<p><img src="chapter1/images/variable.png" alt="" /></p>
<p>Now even if the value of <code>age</code> changes (e.g. to <code>21</code> because a birthday happened), the variable name doesn't change, only the value does.
That is the variable name is still <code>age</code>, however now <code>age</code> has the value <code>21</code> (i.e. <code>age</code> is equal to <code>21</code>):</p>
<p><img src="chapter1/images/variable-changed.png" alt="" /></p>
<p>To continue our &quot;labeled box&quot; metapher, you can <em>change</em> what's inside the box - maybe today it's a rubber duck, tomorrow it's a chocolate chip cookie - but the label on the box stays the <em>same</em>.</p>
<p>JavaScript lets you declare variables with the <code>let</code> keyword.
You can assign values to variables using the <strong>assignment operator</strong> (<code>=</code>):</p>
<pre><code class="language-js">// Declare a variable
let x;

// Assign a value to a variable
x = 10;
</code></pre>
<p>You can print the value of the variable using the <code>console.log</code> method:</p>
<pre><code class="language-js">console.log(x); // 10
</code></pre>
<blockquote>
<p>If you follow along in the Node.js (or browser) console, you don't actually need to use the <code>console.log</code> method to print the value of a variable.
Instead you can simply type the variable (or any expression for that matter) and the console will display its value.</p>
</blockquote>
<p>You can also have a declaration and an assignment on a single line. In fact, this is usually the way to go:</p>
<pre><code class="language-js">let y = 10;
</code></pre>
<p>The value of a variable may change over the course of a program:</p>
<pre><code class="language-js">let y = 10;
console.log(y); // 10

// Assign a new value to the variable
y = 20;
console.log(y); // 20
</code></pre>
<p>This will print <code>10</code> first and then <code>20</code>.</p>
<p>If you want to declare a predictable name for a value that never changes, you can declare a <strong>constant</strong>.
This is done using the <code>const</code> keyword:</p>
<pre><code class="language-js">const ten = 10;
</code></pre>
<p>If you try to reassign a value to a constant, you get an error. For example if you do</p>
<pre><code class="language-js">const ten = 10;
ten = 20;
</code></pre>
<p>you get</p>
<pre><code>Uncaught TypeError: Assignment to constant variable.
</code></pre>
<p>You will almost exclusively see us using <code>const</code> instead of <code>let</code> from now on.
Reassignment is not nearly as necessary as you might think right now.</p>
<blockquote>
<p>You can also declare variables using the <code>var</code> keyword.
We will not cover it here and you essentially only need to know one thing about <code>var</code> - you should <em>basically never use it</em>.
It's mostly a historical artifact of the language at this point.</p>
</blockquote>
<p>Any variable has a <strong>data type</strong> which denotes the range of values it can take and which operations can be performed on the variable.
You can use the <code>typeof</code> operator to obtain the data type of a variable.</p>
<p>We begin with the <strong>primitive data types</strong>.
Let's talk about numbers, booleans, strings and <code>undefined</code>.</p>
<h3 id="numbers"><a class="header" href="#numbers">Numbers</a></h3>
<p>You've already encountered the <code>Number</code> data type:</p>
<pre><code class="language-js">const age = 20;
console.log(typeof age); // number
</code></pre>
<p>Any integer or real number is a <code>Number</code>:</p>
<pre><code class="language-js">console.log(typeof 42); // number
console.log(typeof -20); // number
console.log(typeof 3.4); // number
console.log(typeof -1.7); // number
</code></pre>
<p>So far, so obvious.
However there are also some other things which have type <code>Number</code> like <code>Infinity</code>.
<code>Infinity</code> is a special value that represents mathematical infinity:</p>
<pre><code class="language-js">console.log(typeof Infinity); // number
</code></pre>
<p>We don't care about things like <code>Infinity</code> for now, just keep in mind that JavaScript numbers are more than only integers and real numbers.</p>
<p>You can perform arithmetic on numbers using the usual arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>.
There is also the <code>%</code> (modulo) operator which returns the remainder of a division.
Finally, there is the <code>**</code> operator which does exponentiation:</p>
<pre><code class="language-js">const a = 3;
const b = 4;
console.log(a + b); // 7
console.log(a - b); // -1
console.log(a * b); // 12
console.log(a / b); // 0.75
console.log(a % b); // 3
console.log(a ** b); // 81
</code></pre>
<h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Another primitive type is the <code>Boolean</code> type.
This allows you to represent values which are either <code>true</code> or <code>false</code>:</p>
<pre><code class="language-js">const thisBookIsAwesome = true;
const thisBookSucks = false;
console.log(typeof thisBookIsAwesome); // boolean
console.log(typeof thisBookSucks); // boolean
</code></pre>
<p>You can do simple logic using the logical operators <code>&amp;&amp;</code> (which denotes <strong>and</strong>), <code>||</code> (which denotes <strong>or</strong>) and <code>!</code> (which denotes <strong>not</strong>).</p>
<p>The <code>&amp;&amp;</code> (<em>and</em>) operator takes two values and evaluates to <code>true</code> only if both values are <code>true</code> and to <code>false</code> otherwise:</p>
<pre><code class="language-js">console.log(true &amp;&amp; true); // true
console.log(false &amp;&amp; true); // false
console.log(true &amp;&amp; false); // false
console.log(false &amp;&amp; false); // false
</code></pre>
<p>The <code>||</code> (<em>or</em>) operator takes two values and evaluates to <code>true</code> if <em>at least one</em> of the values is <code>true</code> (and to <code>false</code> otherwise):</p>
<pre><code class="language-js">console.log(true || true); // true
console.log(false || true); // true
console.log(true || false); // true
console.log(false || false); // false
</code></pre>
<p>The <code>!</code> (<em>not</em>) operator takes a single value and simply negates it, i.e. &quot;switches&quot; a value to it's opposite:</p>
<pre><code class="language-js">console.log(!true); // false
console.log(!false); // true
</code></pre>
<p>Here is an example with all the operators together:</p>
<pre><code class="language-js">const b1 = true;
const b2 = false;
console.log(b1 &amp;&amp; b2); // false
console.log(b1 || b2); // true
console.log(!b1); // false
</code></pre>
<blockquote>
<p>Note that technically all the logical operators can take <em>any</em> value (not just boolean values).
The result of the logical operator application is then dependent on whether the values are <em>truthy</em> or <em>falsy</em>.
We will discuss this a bit later.</p>
</blockquote>
<p>A boolean variable is usually the result of an expression.
Often it is the result of an expression containing the <strong>equality operator</strong> (<code>===</code>) which allows us to compare the values of variables:</p>
<pre><code class="language-js">const x1 = 5;
const x2 = 10;
const x3 = 5;
console.log(x1 === x1); // true
console.log(x1 === x2); // false
console.log(x1 === x3); // true
</code></pre>
<blockquote>
<p>There is also another equality operator (<code>==</code>) which performs various type coercions before doing the equality comparison.
This operator can be best described as an April Fools' joke that somehow made it into the language.
<em>Never use it</em>.</p>
</blockquote>
<p>If you want to write <em>not equals</em> you can use <code>!==</code>:</p>
<pre><code class="language-js">console.log(5 !== 10); // true
console.log(5 !== 5); // false
</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Another primitive data type is the <code>String</code> type.
A string is simply a bunch of characters and is used to represent text.
Strings are usually written using single quotes in JavaScript:</p>
<pre><code class="language-js">const s = 'Some text';
console.log(typeof s); // string
</code></pre>
<blockquote>
<p>Note that it's also possible to write strings using double quotes, however in most projects strings are written using single quotes.
We will stick to this convention.</p>
</blockquote>
<p>The <code>+</code> operator works on strings and does concatenation:</p>
<pre><code class="language-js">const s1 = 'MERN ';
const s2 = 'book';
console.log(s1 + s2); // MERN book
</code></pre>
<p>Note that instead of doing concatenation all the time you can also use <strong>template strings</strong> (also called template literals).
This allows writing JavaScript expressions directly inside strings.
Consider the following example:</p>
<pre><code class="language-js">const s = 'world';
const greeting = `Hello ${s}!`;
console.log(greeting); // Hello world!
</code></pre>
<p>Template strings are written using backticks (<em>not</em> single quotes).
They may contain so called <em>placeholders</em> which are expressions embedded inside <code>${...}</code>.
These expressions can be any valid JavaScript expression that evaluates to a value implicitly convertible to a string.
JavaScript will then try to convert any value inside the placeholder to a string:</p>
<pre><code class="language-js">console.log(`2 + 2 = ${2 + 2}`); // 2 + 2 = 4
</code></pre>
<p>You can get the length (i.e. the number of characters) of a string like this:</p>
<pre><code class="language-js">const s = 'MERN book';
console.log(s.length); // 9
</code></pre>
<blockquote>
<p>Note that JavaScript does not have a special &quot;character&quot; data type (unlike Java for example).
Instead, characters are simply strings of length 1.</p>
</blockquote>
<h3 id="undefined"><a class="header" href="#undefined">Undefined</a></h3>
<p>Finally there is one more primitive type that is of interest to us, namely <code>undefined</code>.
There is only one value of this type: <code>undefined</code>.
If a variable has the value <code>undefined</code> this (quite logically) means that it hasn't been defined.
For example, whenever you have a variable that has been initialized, but not assigned to, it will automatically have the value and therefore the type <code>undefined</code>.</p>
<pre><code class="language-js">let someVariable;
console.log(someVariable); // undefined
console.log(typeof someVariable); // undefined
</code></pre>
<blockquote>
<p>Note that <code>string</code>, <code>number</code>, <code>boolean</code> and <code>undefined</code> are not the only primitive data types.
Two other primitive data types are <code>symbol</code> and <code>bigint</code>.
And there is one more primitive data type that we will encounter soon.</p>
</blockquote>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<p>You learned how to declare variables using <code>let</code> and constants using <code>const</code>.
You also learned about the most important primitive data types: numbers, strings, booleans and <code>undefined</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arrays-and-objects"><a class="header" href="#arrays-and-objects">Arrays and objects</a></h2>
<div style="text-align: right"> <i> The object of the superior programmer is truthy. <br> — Confucius </i> </div>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Let's say you are writing a task application (<em>just how did I come up with that example?</em>) and you need to store a bunch of tasks.
You could of course declare a separate variable for every task like this:</p>
<pre><code class="language-js">const task1 = 'First task';
const task2 = 'Second task';
const task3 = 'Third task';
</code></pre>
<p>However this would quickly become very <em>tedious</em>.
In addition you may want to add or delete tasks.
Adding and deleting variables will become even more <em>tedious</em>.
It would become almost as <em>tedious</em> as repeating the word <em>tedious</em> over and over.
Did we mention that this is really <em>tedious</em>?
As you can see, we need a way to store multiple values in a single variable.</p>
<p>A JavaScript <strong>array</strong> is an ordered collection of multiple values.
You can declare an array using an <strong>array literal</strong> (also called an <em>array initializer</em> in this context):</p>
<pre><code class="language-js">const tasks = ['First task', 'Second task', 'Third task'];
</code></pre>
<p>Note that an array is no longer a primitive type, instead arrays have the type <code>object</code>:</p>
<pre><code class="language-js">console.log(typeof tasks); // object
</code></pre>
<p>You can access individual elements of an array using the index notation.
This works by writing the name of the array, followed by the position of the element you want to retrieve inside square brackets.
Note that when we count the indices (positions), we start at <code>0</code>, <em>not</em> at <code>1</code>:</p>
<pre><code class="language-js">console.log(tasks[0]); // First task
console.log(tasks[1]); // Second task
console.log(tasks[2]); // Third task
</code></pre>
<p>If the array index is too big, trying to access the element at that index will return <code>undefined</code>:</p>
<pre><code class="language-js">console.log(tasks[3]); // undefined
</code></pre>
<p>You can get the length of an array by using <code>.length</code>:</p>
<pre><code class="language-js">console.log(tasks.length); // 3
</code></pre>
<p>You can change an array element using the index notation and the assignment operator.
For example here is how you would change the second element of the <code>tasks</code> array (remember that the second element has index <code>1</code>):</p>
<pre><code class="language-js">tasks[1] = 'Some other task';
console.log(tasks[1]); // Some other task
</code></pre>
<blockquote>
<p>Note that even despite the fact the <code>tasks</code> array is declared as a constant here, you can still change the <em>contents</em> of the array.
However you can't <em>reassign</em> <code>tasks</code> to something else, i.e. you can't write something like <code>tasks = [1]</code>.</p>
</blockquote>
<p>JavaScript has some elegant syntax for working with arrays. If you want to assign variables based on values of an array, you would normally have to do something like this:</p>
<pre><code class="language-js">const firstTask = tasks[0];
const secondTask = tasks[1];
const thirdTask = tasks[2];
</code></pre>
<p>This is (you guessed it) <em>tedious</em>.
Instead you can use the <strong>array destructuring assignment</strong>:</p>
<pre><code class="language-js">const [firstTask, secondTask, thirdTask] = tasks;
</code></pre>
<p>If you only care about some of the elements, you can use the <strong>spread</strong> (<code>...</code>) syntax:</p>
<pre><code class="language-js">const [firstTask, ...otherTasks] = tasks;
</code></pre>
<p>Something that commonly trips up beginners is trying to <em>copy</em> an array. Let's say you have an array of numbers called <code>arr</code> and you want to create a copy called <code>arr2</code>.
You would probably try something like</p>
<pre><code class="language-js">const arr = [1, 2, 3, 4];
const arr2 = arr;
</code></pre>
<p>This is <em>wrong</em>. Let's try changing the first element of <code>arr</code> and look at <code>arr[0]</code> and <code>arr2[0]</code>:</p>
<pre><code class="language-js">arr[0] = 5;
console.log(arr[0]); // 5
console.log(arr2[0]); // 5
</code></pre>
<p>Uh-oh!
That's probably not what we want.
The reason for this behaviour is that <code>arr</code> and <code>arr2</code> both point to the same array.
Remember how we were careful to introduce a variable <em>as a storage location together with a symbolic name</em>?
Well, it turns out that <em>different symbolic names</em> may refer to the <em>exact same storage location</em>.
You can visualize it like this:</p>
<p><img src="chapter1/images/array-copy-incorrect.png" alt="" /></p>
<p>Here we have a storage location containing the values <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code> somewhere.
We also have two symbolic names <code>arr</code> and <code>arr2</code>.
While the symbolic names are different, they point to the same storage location.
Therefore if we change the storage location, we will observe a change via both symbolic names.</p>
<p>In order to actually copy the values, we can in fact use the spread syntax as this will <em>copy</em> the values:</p>
<pre><code class="language-js">const copied = [...arr];
</code></pre>
<p>Let's check that this indeed an actual copy:</p>
<pre><code class="language-js">arr[0] = 5;
console.log(arr[0]); // 5
console.log(copied[0]); // 1
</code></pre>
<p>This looks good.
Here is the mental picture you should have in your head for copying an array:</p>
<p><img src="chapter1/images/array-copy-correct.png" alt="" /></p>
<blockquote>
<p>If you only briefly skimmed the section on array destructuring and the spread syntax, go right back and read it carefully.
These two concepts will come up <em>a lot</em> in the following chapters (much more often than you think right now).</p>
</blockquote>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<p>Let's return to our (yet) imaginary task application.
A task will probably be something more than just a string.
For example it might contain an ID, a summary and a description.
We could again store these in constants:</p>
<pre><code class="language-js">const taskId = 1;
const taskSummary = 'Read the Next.js book';
const taskDescription = 'Read and understand the Next.js book.';
</code></pre>
<p>As you can probably guess, this will quickly become <em>tedious</em> (oh no, not this again).
<strong>Objects</strong> to the rescue!
These allow us to store name-value pairs inside a single variable.
Here is how we might create a <code>task</code> object that contains all the information we want to know about a task:</p>
<pre><code class="language-js">const task = {
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>Every such value is called a <strong>property</strong>.
We can access properties using the dot notation or the square bracket notation.
For example to access the <code>summary</code> property of the <code>task</code> object, you would write <code>task.summary</code> or <code>task['summary']</code>.
Try it out:</p>
<pre><code class="language-js">console.log(task.id); // 1
console.log(task.summary); // Read the Next.js book
console.log(task.description); // Read and understand the Next.js book.
console.log(task['id']); // 1
console.log(task['summary']); // Read the Next.js book
console.log(task['description']); // Read and understand the Next.js book.
</code></pre>
<blockquote>
<p>Note that we will practically always use the dot notation.</p>
</blockquote>
<p>Properties don't have to be primitive values.
They can also be other objects.
Generally speaking, you can arbitrarily nest objects and arrays.
For example, here is how you can nest an object inside an object:</p>
<pre><code class="language-js">const person = {
  name: 'John Doe',
  task: {
    id: 1,
    summary: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
  },
};
</code></pre>
<p>In this case you can use the <code>.</code> notation to access properties at any nesting level.
Let's say you want to get the summary of the task that's been assigned to the <code>person</code>.
Then you can write <code>person.task.summary</code>:</p>
<pre><code class="language-js">console.log(person.task.summary); // Read the Next.js book
</code></pre>
<p>If you try to access a property that doesn't exist, the result will be <code>undefined</code> (there it is again):</p>
<pre><code class="language-js">console.log(task.date); // undefined
</code></pre>
<p>Sometimes you want to explicitly indicate that a property may be absent.
For example a person may not have a task assigned to them.
You could do something like this:</p>
<pre><code class="language-js">const person = {
  name: 'John Doe',
  task: undefined,
};
</code></pre>
<p>This has the <em>potential</em> problem that someone referring to <code>person.task</code> will have no idea whether it is <code>undefined</code> because the property is not supposed to exist at all or because it it simply absent for this particular person.
This is why JavaScript introduced <code>null</code>:</p>
<pre><code class="language-js">const person = {
  name: 'Max Mustermann',
  task: null,
};
</code></pre>
<p>Basically <code>null</code> allows you to say - &quot;hey, this property does exist in principle, it's just absent for this particular variable&quot;.
However this is only a convention.
There is nothing that prevents you from using <code>undefined</code> to denote absence all the time and in fact we will do so in this very book.
Just keep in mind that <code>null</code> exists and that some developers use it to indicate absence (and that it's totally fine to do so).</p>
<p>Remember how we said that there is one more primitive data type left?
Well - there it is.
The final primitive data type is <code>null</code>.
This is something a lot of people are really confused about, because <code>typeof null</code> returns <code>object</code> (and not e.g. <code>null</code>).
However this is primarily a technical detail.
Despite the fact that <code>null</code> is a separate data type it doesn't hurt to think of it as an object (namely an absent one).</p>
<p>Just as with arrays, you can use <strong>destructuring assignment</strong> when working with objects:</p>
<pre><code class="language-js">const task = {
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
const { id, summary, description } = task;
</code></pre>
<p>And just like with arrays, you can use the spread syntax:</p>
<pre><code class="language-js">const taskWithAssignee = {
  assignee: 'Max',
  ...task,
};
console.log(taskWithAssignee);
</code></pre>
<p>This will print:</p>
<pre><code class="language-json">{
  &quot;assignee&quot;: &quot;Max&quot;,
  &quot;id&quot;: 1,
  &quot;summary&quot;: &quot;Read the Next.js book&quot;,
  &quot;description&quot;: &quot;Read and understand the Next.js book.&quot;
}
</code></pre>
<blockquote>
<p>Note that objects are more than just containers for values.
We will talk about this in the section on functions.</p>
</blockquote>
<h3 id="summary-2"><a class="header" href="#summary-2">Summary</a></h3>
<p>You have learned how to work with arrays and objects.
You have also learned about (array and object) destructuring and the spread syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h2>
<div style="text-align: right"> <i> Don't push the for loop, it flows by itself. <br> — Ancient Chinese proverb </i> </div>
<h3 id="if-statements"><a class="header" href="#if-statements">If statements</a></h3>
<p>Quite often, we need to make <em>decisions</em> in our programs.
Let's say we want to display a fancy message when a bunch of tasks are completed.
This is a decision: <em>If</em> all the tasks are completed, <em>then</em> we want to display a message.
Put generally: <em>If</em> a condition holds (is true), <em>then</em> we want to do something.</p>
<p>Conveniently, the language keyword that allows us to accomplish this is called <code>if</code>:</p>
<pre><code class="language-js">const completed = true;
if (completed) {
  console.log('Hooray, you completed all your tasks!');
}
</code></pre>
<p>This would print:</p>
<pre><code>Hooray, you completed all your tasks!
</code></pre>
<p>The general form of an <code>if</code> statement looks like this:</p>
<pre><code class="language-js">if (condition) {
  statements;
}
</code></pre>
<p>If <code>condition</code> is true, then the <code>statements</code> inside the curly braces will be executed.
If <code>condition</code> is false, nothing will happen.</p>
<blockquote>
<p>Note that technically it suffices if the condition is <em>truthy</em> or <em>falsy</em>. We will ignore this detail for now and return to it in a second.</p>
</blockquote>
<p>The simplest condition is a boolean variable.
However, nothing prevents us from writing more complex conditions.
For example, let's say we have a list of uncompleted tasks (conveniently) named <code>tasks</code>.
Then we could check that all tasks have been completed by checking whether <code>tasks</code> is empty (i.e. the length of <code>tasks</code> is zero):</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
}
</code></pre>
<p>Sometimes you need to do something in one case and something else in another case.
The (also conveniently named) <code>else</code> keyword allows you to accomplish exactly that.
Let's say that if all the tasks haven't been completed yet, we want to display a different message:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
} else {
  console.log('You still have some tasks to complete.');
}
</code></pre>
<p>The general form of an <code>if...else</code> statement looks like this:</p>
<pre><code class="language-js">if (condition) {
  block1;
} else {
  block2;
}
</code></pre>
<p>If <code>condition</code> is true, the statements corresponding to <code>block1</code> will be executed (i.e. the statements inside the curly braces after the <code>if</code>).
If <code>condition</code> is false, the statements corresponding to <code>block2</code> will be executed (i.e. the statements inside the curly braces after the <code>else</code>).</p>
<p>Note that there may be multiple statements between the curly braces.
This is totally valid:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
  console.log('Congratulations!');
  console.log('No really, you are amazing!');
} else {
  console.log('You still have some tasks to complete.');
  console.log('Do not despair!');
}
</code></pre>
<p>Assuming <code>tasks</code> has a <code>length</code> of <code>0</code> this will print:</p>
<pre><code>Hooray, you completed all your tasks!
Congratulations!
No really, you are amazing!
</code></pre>
<p>Sometimes you need to handle more than two cases.
Since JavaScript was fresh out of keywords at this point, they allowed you to do so using <code>else if</code>:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
} else if (tasks.length === 1) {
  console.log('Only one task left! Go! Go! Go!');
} else {
  console.log('You still have some tasks to complete.');
}
</code></pre>
<p>The general form of an <code>if...else if...else</code> statement looks like this:</p>
<pre><code class="language-js">if (condition1) {
  block1;
} else if (condition2) {
  block2;
} /*possibly more else ifs*/ else if (conditionN) {
  blockN;
} else {
  blockElse;
}
</code></pre>
<p>Here all the conditions will be checked one after another.
As soon as a condition is true, the corresponding statements will be executed.
If no condition matches, the statements corresponding to <code>statementsElse</code> will be executed.</p>
<p>You can have any number of <code>else if</code> statements.
For example, this is valid:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
} else if (tasks.length === 1) {
  console.log('Only one task left! Go! Go! Go!');
} else if (tasks.length === 2) {
  console.log('You have two tasks to do.');
} else if (tasks.length === 3) {
  console.log('There are three tasks left.');
} else {
  console.log('You still have some tasks to complete.');
}
</code></pre>
<p>Note that the <code>else</code> block is not required.
If it's missing and none of the conditions are true, nothing will happen.</p>
<h3 id="truthiness-and-falsiness"><a class="header" href="#truthiness-and-falsiness">Truthiness and falsiness</a></h3>
<p>Note that the condition does not necessary have to be boolean as JavaScript will automatically evaluate non-boolean values as &quot;truthy&quot; or &quot;falsy&quot; in boolean contexts.
For example you could write something like this:</p>
<pre><code class="language-js">if (1) {
  console.log('1 is truthy.');
} else {
  console.log('1 is falsy.');
}
</code></pre>
<p>This will print &quot;1 is truthy.&quot; because JavaScript will consider <code>1</code> to be <code>true</code> in this context since <code>1</code> is a <em>truthy</em> value.</p>
<p>Generally speaking, a <strong>truthy</strong> value is considered to be true when encountered in a boolean context (like a condition).
A <strong>falsy</strong> value is considered to be false when encountered in a boolean context.
The most important falsy values are <code>false</code>, <code>0</code>, <code>''</code> (empty string), <code>null</code> and <code>undefined</code>.
Most other values (like <code>1</code>, <code>[]</code> (empty array), <code>[3]</code>, <code>{ example: 'hello' }</code> etc) are truthy.</p>
<p>Try to <em>avoid using non-boolean values in boolean contexts</em> as it can lead to surprising behaviour.
Nevertheless it's still useful to know about truthiness and falsiness, as it will otherwise trip you up in certain cases.</p>
<h3 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary operator</a></h3>
<p>The <strong>ternary operator</strong> takes a <em>condition</em>, an <em>expression to execute if the condition is truthy</em> and an <em>expression to execute if the condition is falsy</em>.
It looks like this:</p>
<pre><code class="language-js">const doneMsg = 'All tasks are done';
const notDoneMsg = 'There are tasks left';
const msg = done ? doneMsg : notDoneMsg;
</code></pre>
<p>The general form is:</p>
<pre><code class="language-js">condition ? expression1 : expression2;
</code></pre>
<p>You can think of the ternary operator as a short, compact way to write an <code>if ... else</code> statement.
It evaluates a condition, and if that condition is <code>true</code> (truthy), the result will have the value of the first expression.
If the condition is <code>false</code> (falsy), the result will have the value of the second expression.</p>
<p>There is a very common thing complete beginners do with ternary operators which looks like this:</p>
<pre><code class="language-js">const finished = tasks.length === 0 ? true : false;
</code></pre>
<p>You should stop for a second and think about why this is unnecessary.</p>
<p><em>Thought</em> about it?
That's right - the expression <code>tasks.length === 0</code> already evaluates to a boolean value.
You can just write</p>
<pre><code class="language-js">const finished = tasks.length === 0;
</code></pre>
<h3 id="optional-chaining"><a class="header" href="#optional-chaining">Optional chaining</a></h3>
<p>Consider the following task object:</p>
<pre><code class="language-js">const nextTask = {
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book',
  date: {
    day: 8,
    month: 6,
    year: 2022,
  },
};
</code></pre>
<p>Let's say we want to access the day of the task.
We can do this by using <code>nextTask.date.day</code>.
But what if the day does not have to be present, i.e. is <em>optional</em>?
This could happen, for example, because the user didn't enter a task.</p>
<p>The object could look like this:</p>
<pre><code class="language-js">const nextTask = {
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book',
};

// or like this if you were to use `null`
const nextTask = {
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book',
  date: null,
};
</code></pre>
<p>Then <code>nextTask.date.day</code> will fail with</p>
<pre><code>Uncaught TypeError: Cannot read properties of undefined (reading 'day')
</code></pre>
<p>This makes sense since <code>nextTask.date</code> will result in <code>undefined</code> and you can't access a property on <code>undefined</code>.
But let's say we would like to access the day and set it to <code>undefined</code> if the <code>date</code> property is not present.
Then we would need to do something like the following:</p>
<pre><code class="language-js">const day = nextTask.date !== undefined ? nextTask.date.day : undefined;
</code></pre>
<p>Here is what this line does:
If <code>nextTask.date</code> is defined, then <code>nextTask.date.day</code> is assigned to <code>day</code>.
If <code>nextTask.date</code> is not defined, the <code>undefined</code> is assigned to <code>day</code>.</p>
<p>Alternatively we could make use of <code>&amp;&amp;</code> and write:</p>
<pre><code class="language-js">const day = nextTask.date &amp;&amp; nextTask.date.day;
</code></pre>
<blockquote>
<p>This is correct because of the way the <code>&amp;&amp;</code> works.
If the first expression is <code>false</code> (or falsy) then <code>&amp;&amp;</code> doesn't look at the second expression and immediately returns the value of the first expression.
If the first expression is <code>true</code> (or truthy) then <code>&amp;&amp;</code> returns the second expression.</p>
</blockquote>
<p>Generally consider an object that has a bunch of values that may be absent (i.e. <code>null</code> or <code>undefined</code>).
Working with such values will be annoying and only grow more cumbersome with deeper nesting.
To avoid all this JavaScript allows you to do <strong>optional chaining</strong>.
This works by writing <code>?.</code> instead of <code>.</code> when trying to work on something that may be <code>undefined</code>.
The above line would then become:</p>
<pre><code class="language-js">const day = nextTask.date?.day;
</code></pre>
<p>Now the result will be <code>undefined</code> instead of giving you a TypeError.</p>
<h3 id="forof-loops"><a class="header" href="#forof-loops">For..of loops</a></h3>
<p><code>For..of</code> loops allow you to <em>iterate over arrays and strings</em> (and some other things that we will cover later on) and perform a task for each element / character.
Let's say you want to print all tasks from a list named <code>tasks</code>.
You could do it like this:</p>
<pre><code class="language-js">const tasks = ['Task 1', 'Task 2', 'Task 3'];
for (let task of tasks) {
  console.log(task);
}
</code></pre>
<p>This would print</p>
<pre><code>Task 1
Task 2
Task 3
</code></pre>
<p>As we already mentioned, you can use a <code>for..of</code> loop to iterate over a string:</p>
<pre><code class="language-js">const str = 'Task';
for (let char of str) {
  console.log(char);
}
</code></pre>
<p>This would print each character of the string, i.e.:</p>
<pre><code>T
a
s
k
</code></pre>
<p>The general syntax of a <code>for..of</code> loop is</p>
<pre><code class="language-js">for (let variable of arrayOrString) {
  statements;
}
</code></pre>
<p>It should be noted that if you don't change the variable inside the loop, you can and should also declare it as <code>const</code>.
Our first example could therefore be rewritten to</p>
<pre><code class="language-js">const tasks = ['Task 1', 'Task 2', 'Task 3'];
for (const task of tasks) {
  console.log(task);
}
</code></pre>
<blockquote>
<p>There are also a bunch of other loops (like <code>while</code> and <code>do...while</code>) that we will cover later.
However, <code>for...of</code> loops are commonly used and often sufficient for many use cases</p>
</blockquote>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<p>You learned how to make decisions using <code>if</code> statements, <code>if...else</code> statements, <code>if...else if...else</code> statements and the ternary operator.
You also learned how to address missing properties using <em>optional chaining</em>.
Finally you learned how to iterate over strings and arrays using the <code>for...of</code> loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<div style="text-align: right"> <i> A function with no purpose is like a dragon with no fire. <br> — Ancient Chinese proverb </i> </div>
<h3 id="declaring-and-calling-functions"><a class="header" href="#declaring-and-calling-functions">Declaring and Calling Functions</a></h3>
<p>When programming we often have to perform some common actions over and over again.
For example we might want to get the list of tasks assigned to a user at multiple parts within our software.
Instead of writing code that (essentially) does the same thing multiple times we could use a <strong>function</strong>.</p>
<p>Within the <strong>function definition</strong> we would specify what statements should be executed.
Then we can write a <strong>function call</strong> (also called <strong>function invocation</strong>).
This would then actually execute the statements specified in the definition.
We can simply group common actions into a function and then just call the function whenever we need to execute those actions.</p>
<p>Here is a very simple function definition:</p>
<pre><code class="language-js">function printGreeting() {
  console.log('Hello world!');
}
</code></pre>
<p>Function definitions begin with the <code>function</code> keyword followed by the function name (in this case <code>printGreeting</code>).
We will cover the meaning of the parentheses in a second, but the curly braces contain the <em>body</em> of the function.
These are all the statements that will be executed when the function is called.
In this case we have one statement, which will simply print <code>Hello world!</code> to the console.</p>
<p>You can call / invoke the <code>printGreeting</code> function by writing <code>printGreeting()</code>:</p>
<pre><code class="language-js">printGreeting(); // Hello world!
</code></pre>
<p>You can of course have as many statements as you want inside the function body:</p>
<pre><code class="language-js">function printGreetings() {
  console.log('Hello world!');
  console.log('Hello again!');
}
</code></pre>
<p>These functions are not particularly interesting since they do the exact same thing for every function call.
In this case, we print the exact same greeting(s) every time.
But what if we wanted to print a different greeting depending on the user (containing e.g. the user name)?</p>
<p>We can solve this by defining <strong>function parameters</strong>.
This allows us to pass values into the function, so that the function can adjust its behaviour.
The function parameters go between the parentheses:</p>
<pre><code class="language-js">function printGreeting(user) {
  console.log(`Hello ${user}!`);
}

printGreeting('Jane'); // Hello Jane!
</code></pre>
<p>In this example we have a single parameter called <code>user</code>.
The function prints the greeting with the appropriate user.
Within the function call we then pass the user (in this case <code>Jane</code>) as an <strong>argument</strong> to the function.</p>
<p>We can also <strong>return</strong> values from functions using the <code>return</code> keyword.
This keyword is used to specify the result that the function should produce, which can then be used in other parts of your code.</p>
<p>Here is a function that takes a number and returns the square of it:</p>
<pre><code class="language-js">function square(num) {
  return num * num;
}
</code></pre>
<p>We can now use the function as follows:</p>
<pre><code class="language-js">const squaredNum = square(3);
console.log(squaredNum); // 9
</code></pre>
<h3 id="functions-are-objects"><a class="header" href="#functions-are-objects">Functions are Objects</a></h3>
<p>Despite the fact that you get &quot;function&quot; when you use <code>typeof</code> with a function, functions are really just objects.</p>
<p>This means that we can assign functions as variables, pass them to other functions as arguments and do all the other neat things we can do with primitives and objects.
For example we could assign the <code>square</code> function to a variable:</p>
<pre><code class="language-js">const square = function square(num) {
  return num * num;
};
</code></pre>
<p>We could then call this like a regular function by doing e.g. <code>square(3)</code>.</p>
<p>This is called a <strong>function expression</strong>.
Note that the function may be <strong>anonymous</strong> here (i.e. it doesn't have a name).
We could write this:</p>
<pre><code class="language-js">const square = function (num) {
  return num * num;
};
</code></pre>
<p>The syntax for calling such a function is still the same, e.g. we could write <code>square(3)</code>.</p>
<h3 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h3>
<p>There is a shorthand notation available in JavaScript called the <strong>arrow function</strong> notation.
This notation allows you to omit certain keywords in certain situations.
For example here is how you could rewrite the <code>square</code> function using the arrow function notation:</p>
<pre><code class="language-js">const square = (num) =&gt; num * num;
</code></pre>
<p>This is much shorter and less <em>tedious</em> (haha) indeed.</p>
<p>For an arrow function you only have to specify the parameter(s), followed by an arrow, followed by the returned value.
If you have multiple parameters, you need to put them inside parentheses:</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y;
</code></pre>
<p>You can also have multiple statements in the function body, but then you have to specify the <code>return</code> keyword and surround the statements with curly braces:</p>
<pre><code class="language-js">const printAndGreet = (user) =&gt; {
  const greeting = `Hello ${user}`;
  console.log(greeting);
  return greeting;
};
</code></pre>
<p>As you can see this is not too different from a regular function declaration or expression (unlike the <code>square</code> function, where the arrow notation was much shorter).
It is therefore common practice to only use arrow functions for short functions like <code>square</code>.
However this is again just convention.</p>
<p>One thing you might have noticed, is that we only showed you <strong>arrow function expressions</strong>.
This is not an oversight but stems from the fact that there is no way to write a <strong>function declaration</strong> with the <strong>arrow function notation</strong>.</p>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>A method is a function which is a property of an object.</p>
<pre><code class="language-js">const greeter = {
  greet: function () {
    console.log('Hello, world!');
  },
};
</code></pre>
<p>You can call a method like this:</p>
<pre><code class="language-js">greeter.greet(); // Hello, world!
</code></pre>
<p>Methods can refer to the properties of an object using the <code>this</code> keyword which is simply a reference to the current object:</p>
<pre><code class="language-js">const task = {
  id: 1,
  summary: 'Read the MERN book',
  description: 'Read and understand the MERN book.',
  longDescription: function () {
    return `${this.summary}(ID = ${this.id}): ${this.description}`;
  },
};
</code></pre>
<p>You can call the method by doing <code>task.longDescription()</code>.
This would print:</p>
<pre><code>Read the MERN book(ID = 1): Read and understand the MERN book.
</code></pre>
<p>Methods can also change properties of objects.</p>
<p>We will not dwell on methods for too long, since we will not use them all that often as this would lead to a <em>ghastly</em> thing called <em>Object-Oriented Programming</em> (OOP for short).
Instead we want you to think <em>functionally</em>, which is what the next section will be about.</p>
<blockquote>
<p>Inevitable disclaimer for <em>certain</em> Java/C#/... people:
The sentence about OOP was a joke and used correctly, OOP has its merits.
We just wanted to be funny.
We're very sorry about that and will now perform the appropriate penance procedure.</p>
</blockquote>
<h3 id="summary-4"><a class="header" href="#summary-4">Summary</a></h3>
<p>You learned how to declare and call functions and methods.
You also learned about the arrow notation as a convenient shorthand for functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functional-thinking"><a class="header" href="#functional-thinking">Functional Thinking</a></h2>
<div style="text-align: right"> <i> Gold can't be pure, but functions can. <br> — Ancient Chinese proverb </i> </div>
<h3 id="pure-functions"><a class="header" href="#pure-functions">Pure Functions</a></h3>
<p>A function is called <strong>pure</strong> if its outputs (the returned values) depend only on its inputs and if the function does not have any <em>side effects</em> (i.e. it doesn't change program state and doesn't write anything to an external data source).</p>
<p>Here is an example of a pure function:</p>
<pre><code class="language-js">const square = (x) =&gt; x * 2;
</code></pre>
<p>Indeed, the output of <code>square</code> depends only on its input and nothing else.
In addition, <code>square</code> doesn't produce any side effects.</p>
<p>Here is an example of a function that is <em>not</em> pure:</p>
<pre><code class="language-js">const x = 2;
const addImpure = (y) =&gt; x + y;
</code></pre>
<p>The output of this function doesn't depend just on its input variables, but also on a global variable <code>x</code>.</p>
<p>Here is another function that's not pure:</p>
<pre><code class="language-js">const hello = () =&gt; console.log('Hello, world!');
</code></pre>
<p>The <code>hello</code> function has a side effect - it outputs something to the console.</p>
<p>Why do we care about all of this?
The fundamental reason is that <em>pure functions are very easy to reason about</em>.
There is practically no room for suprising behaviour.</p>
<p>Consider the above <code>square</code> function.
It takes an input and produces an output that is dependent <em>only on the input</em>.
It doesn't matter what the rest of the program is doing - the function will always produce identical outputs for identical inputs.</p>
<blockquote>
<p>If you are mathematically inclined, pure functions are basically regular mathematical functions.
They take an input which is a member of some domain and produce an output which is a member of some codomain.
For example the <code>square</code> function is simply the function f: A → B, f(x) = x² where A and B are certain sets of numbers.
Note that A and B are emphatically <em>not</em> equal to the set of real numbers since of course JavaScript cannot represent every possible real number (due to underlying hardware limitatations - computers can't possibly store arbitrarily large numbers).</p>
</blockquote>
<p>All of the above is not true for the <code>addImpure</code> function.
This function can produce <em>different</em> outputs for identical inputs.
This makes it hard very hard to troubleshoot if there is an error.
After all you may not know what the (global) state of the program was when the error occured.</p>
<p>Closely related is another very nice property of pure functions - they are <em>easily testable</em>.
There is no need to fake some global state - as the function only takes an input and produces some output.
Therefore all you need to do is to call the function, pass some input and check whether the output matches the expected output.
We will return to this <em>extensively</em> when we cover testing.</p>
<h3 id="immutability"><a class="header" href="#immutability">Immutability</a></h3>
<p>A variable is <strong>immutable</strong> if it is unchangeable.
Otherwise we call it <strong>mutable</strong>.
The more mutability we have inside our program the more can go wrong since it's hard to reason about (global) state.</p>
<p>This is where the alert reader might interject - after all, isn't the purpose of a program to do something?
And how can we achieve that if we don't change state?</p>
<p>A fundamental correction is in order here - the purpose of every program is not <em>to do something</em>, but to <em>manipulate data</em>.
You can of course manipulate data directly by mutating global state.</p>
<p>Consider the following <code>task</code> object:</p>
<pre><code class="language-js">const task = {
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>Now let's say we want to change the summary:</p>
<pre><code class="language-js">task.summary = 'Next.js book';
</code></pre>
<p>This works for simple objects and changes.
But this will quickly become brittle with growing complexity.
<em>Reasoning about state and state changes is really hard.</em></p>
<p>Instead we can create copies of the objects which contain the changes we need:</p>
<pre><code class="language-js">const newTask = {
  ...task,
  summary: 'Next.js book',
};
</code></pre>
<p>Note that we didn't change the original object, but created a copy of the object with a different summary.</p>
<p>Immutability and pure functions are closely linked.
You want to have immutable datastructures which get passed through pure functions to compute results.</p>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-order functions</a></h3>
<p>We already talked about the fact that JavaScript functions are just objects.
We even showed an example of how you can assign a function to a variable:</p>
<pre><code class="language-js">const square = (num) =&gt; num * num;
</code></pre>
<p>However we can do much more. Since functions are just objects we can <em>pass them to other functions</em>.
For example let's define a function that repeats some action <code>n</code> times:</p>
<pre><code class="language-js">function repeat(fun, n) {
  for (let i = 0; i &lt; n; i++) {
    fun();
  }
}
</code></pre>
<p>We can use it like this:</p>
<pre><code class="language-js">const hello = () =&gt; console.log('Hello, world!');
repeat(hello, 4);
</code></pre>
<p>This will output:</p>
<pre><code>Hello, world!
Hello, world!
Hello, world!
Hello, world!
</code></pre>
<p>Note that the <code>repeat</code> function doesn't care what <code>fun</code> is - <code>fun</code> could be a simple <code>console.log</code> or a function which produces a simulated universe.
All the <code>repeat</code> function does is to simply repeat <code>fun</code> the specified number of times.</p>
<p>Functions which take (or return) functions are called <strong>higher-order functions</strong>.</p>
<h3 id="the-trinity-of-map-reduce-and-filter"><a class="header" href="#the-trinity-of-map-reduce-and-filter">The trinity of map, reduce and filter</a></h3>
<p>We now introduce the three most important higher-order functions - <code>map</code>, <code>reduce</code> and <code>filter</code>.
These functions allow you to perform an <em>incredibly</em> rich set of operations on arrays.</p>
<blockquote>
<p>We want to use this blockquote to emphasize <em>how often</em> you will be using <code>map</code>, <code>reduce</code> and <code>filter</code>.</p>
</blockquote>
<p>We will use two running examples throughout the section - an array of <code>numbers</code> and an array of <code>tasks</code>:</p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4];
const tasks = [
  {
    id: 1,
    summary: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    timeLogged: 60,
    status: 'In progress',
  },
  {
    id: 2,
    summary: 'Write a task app',
    description: 'Write an awesome task app.',
    timeLogged: 0,
    status: 'Todo',
  },
  {
    id: 3,
    summary: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    timeLogged: 120,
    status: 'In progress',
  },
];
</code></pre>
<p>The <code>map</code> function takes one argument - a function <code>f</code> to apply to every element of the array.
It returns the array resulting from applying <code>f</code> to every element of the original array.</p>
<p>Let's say we wanted to square all the elements of <code>numbers</code>.
We could write something like this:</p>
<pre><code class="language-js">const result = [];
for (const number in numbers) {
  result.push(number ** 2);
}
</code></pre>
<p>This is ugly and (you guessed it) <em>tedious</em>.
Instead we can (and should) use the <code>map</code> function:</p>
<pre><code class="language-js">const result = numbers.map((number) =&gt; number ** 2);
</code></pre>
<p>The <code>result</code> array has the following content:</p>
<pre><code class="language-js">[1, 4, 9, 16];
</code></pre>
<p>Consider another example.
Let's say we wanted to add a long description to all the <code>tasks</code> based on the summary and the description.
We can use the <code>map</code> function again:</p>
<pre><code class="language-js">const longTasks = tasks.map((task) =&gt; ({
  ...task,
  longDescription: `${task.summary}: ${task.description}`,
}));
</code></pre>
<blockquote>
<p>You can see why the spread syntax is so handy.
Thanks to this <em>incredible innovation</em>, you only need to explicitly specify the object parts where something interesting happens.</p>
</blockquote>
<p>The <code>longTasks</code> array will look like this:</p>
<pre><code class="language-js">[
  {
    id: 1,
    summary: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    timeLogged: 60,
    status: 'In progress',
    longDescription: 'Read the Next.js book: Read and understand the Next.js book.',
  },
  {
    id: 2,
    summary: 'Write a task app',
    description: 'Write an awesome task app.',
    timeLogged: 0,
    status: 'Todo',
    longDescription: 'Write a task app: Write an awesome task app.',
  },
  {
    id: 3,
    summary: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    timeLogged: 120,
    status: 'In progress',
    longDescription: 'Think of a funny joke: Come up with a funny joke to lighten the mood.',
  },
];
</code></pre>
<p>The <code>filter</code> function allows you to select elements from an array based on some condition.
It takes a function <code>f</code> which returns <code>true</code> or <code>false</code> for some input(s).
All elements for which <code>f</code> returns <code>true</code> are kept, all elements for which <code>f</code> returns <code>false</code> are thrown away.</p>
<blockquote>
<p>A function which returns <code>true</code> or <code>false</code> is commonly referred to as a <em>predicate</em>.</p>
</blockquote>
<p>For example let's say we want to select all even elements from <code>numbers</code>.
Here is the non-functional way:</p>
<pre><code class="language-js">const result = [];
for (const number in numbers) {
  if (number % 2 === 0) {
    result.push(number ** 2);
  }
}
</code></pre>
<p>Ugh!
I don't even want to look at that.
For loops and if statements all over the place.
Let's rest our eyes and consider the <em>functional</em> approach:</p>
<pre><code class="language-js">const result = numbers.filter((number) =&gt; number % 2 === 0);
</code></pre>
<p>Consider another example - we might want to select all tasks from the <code>tasks</code> array which have the status 'Todo'.
Think for a moment what the appropriate predicate would be.</p>
<p>That's right, it looks like this:</p>
<pre><code class="language-js">const todoTasks = tasks.filter((task) =&gt; task.status === 'Todo');
</code></pre>
<p>Finally there is the <code>reduce</code> function which (you guessed it) <em>reduces</em> an array to a single value.
The <code>reduce</code> function moves over an array from left to right and keeps track of a value (a so called <em>accumulator</em>).
At every element of the array it recomputes the accumulator based on a function <code>f</code> (this function <code>f</code> is the first argument of the <code>reduce</code> function).
The second argument of the reduce function is the initial value.</p>
<p>Here is how we might compute the sum of an array:</p>
<pre><code class="language-js">const sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
<p>Basically this is what happens:
The <code>reduce</code> function looks at <code>acc</code> (which is the initial value, i.e. <code>0</code> at the beginning) and <code>curr</code> (which is <code>1</code>), produces <code>acc + curr</code>, and sets this as the new accumulator (i.e. the new accumulator is <code>1</code>).
Next the <code>reduce</code> function again looks at <code>acc</code> (which is now <code>1</code>) and <code>curr</code> (which is <code>2</code>), produces <code>acc + curr</code>, and sets this as the new accumulator (i.e. the new accumulator is <code>3</code>).
The next update results in the accumulator being <code>6</code> and the final update result in the accumulator being <code>10</code>.
Therefore <code>sum</code> will be <code>10</code>.</p>
<p>For another example, let's say we would like to compute the total logged time (i.e. the time logged for all the tasks combined).
This would look like this:</p>
<pre><code class="language-js">const totalTime = tasks.reduce((task, curr) =&gt; task.loggedTime + curr, 0);
</code></pre>
<blockquote>
<p>We recommend that you try to reason through this <code>reduce</code> for a deeper understanding of this topic.</p>
</blockquote>
<h3 id="summary-5"><a class="header" href="#summary-5">Summary</a></h3>
<p>You learned about important functional concepts like pure functions, immutability and higher-order functions.
You also learned about the three most important higher-order functions - <code>map</code>, <code>filter</code> and <code>reduce</code>.</p>
<h3 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h3>
<p>There is no further reading for this section.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h2>
<div style="text-align: right"> <i> - proverb Ancient Chinese <br> is hard Asynchronous programming </i> </div>
<h3 id="why-asynchronous-programming"><a class="header" href="#why-asynchronous-programming">Why Asynchronous Programming?</a></h3>
<p>We often need to execute long-running operations (especially in web development).
For example, we might need to fetch a resource from a server or request camera access from a user.
In the first case, we need to wait for all the network packets to arrive, which might take a long time depending on your network connectivity.
In the second case, we need to wait for the user to grant us access to the resource we require.</p>
<p>We want do be able to do this without &quot;blocking&quot;.
To accomplish this, we need to break with the &quot;synchronous&quot; programming model where statements are executed one after another.</p>
<p>Consider the following example:</p>
<pre><code class="language-js">function getTask(taskId) {
  return `Task with ID ${taskId}`;
}

const task = getTask(0);
console.log(task);
</code></pre>
<p>The <code>getTask</code> function is a <strong>synchronous function</strong>.
This means that the calling code (i.e. <code>const task = getTask(0)</code>) has to wait until <code>getTask</code> has finished its work to continue.
That is all fine and dandy here, given that <code>getTask</code> should (hopefully) complete its &quot;work&quot; very fast.</p>
<p>But what if <code>getTask</code> represents a long-running operation, like retrieving a task from a server?</p>
<pre><code class="language-js">function getTask(taskId) {
  return retrieveTaskFromServer(taskId);
}

const task = getTask(0);
console.log(task);
</code></pre>
<p>Now the calling code has to wait for the request to complete before it can do anything else.
This will become a huge problem in the browser environment, given that synchronous functions like <code>getTask</code> are &quot;blocking&quot;.
Therefore as long as <code>getTask</code> is executing, no other code will be able to run, including code that handles user events.
This means that the user will not be able to select text, click buttons or do anything else with the website, i.e. the website &quot;hangs&quot;.</p>
<p>Of course we want to avoid such a nuisance since this will result in the much dreaded <em>negative user experience</em>.</p>
<blockquote>
<p>If you ever clicked a button on a website and everything just freezes for three seconds, this often means that some developer wrote a synchronous function that handles a long-running task.</p>
</blockquote>
<p>We need a mechanism to start a (potentially) long-running task and still be able to do other things (like respond to user events) instead of blocking until the task is finished.
Once the task is completed, our program needs to be notified with result.</p>
<p>Here is a step-by-step breakdown of what we want to accomplish:</p>
<ol>
<li>Call a function that starts a long-running operation.</li>
<li>The function should return immediately, so that the &quot;main&quot; program is able to do something else.</li>
<li>Once the long-running operation is completed, the &quot;main&quot; program should be notified.</li>
</ol>
<blockquote>
<p>In case you think to yourself right now &quot;this all sounds very complicated and when do I need long-running tasks anyway, maybe I'll skip this section&quot; - don't.
Almost every project you'll write (essentially when doing web development) will contain asynchronous code.</p>
</blockquote>
<h3 id="promises"><a class="header" href="#promises">Promises</a></h3>
<p>The central object in asynchronous JavaScript is the <strong>promise</strong>.
A promise represents the eventual completion (or failure) of an asynchronous operation.</p>
<p>Basically a promise is a like an IOU document - it &quot;promises&quot; you that it is currently working on some long-running operation and that it will eventually get back to you with the result of that long-running operation.</p>
<p>If you want another metaphor, you can think about how you would order a hamburger at a fast food restaurant.
In the “synchronous” world, you would walk up, tell your order to the hardworking employee of the restaurant and then immediately receive your hamburger.
However since the preparation of a hamburger does not happen immediately (it's a &quot;long-running operation&quot;), the synchronous approach would block both you and the kitchen from doing something else.</p>
<p>Instead the employee hands you an order receipt with a number.
That order receipt is the promise that represents the eventual completion of the asynchronous operation (preparing your hamburger).</p>
<p>We say that a promise is <strong>pending</strong> when it has been created, but the asynchronous operation it represents has not been completed yet.
We say that a promise is <strong>fulfilled</strong> when the asynchronous operation it represents has been successfully completed.
Finally a promise is <strong>rejected</strong> when the asynchronous operation it represents has failed.</p>
<h3 id="working-with-promises-in-javascript"><a class="header" href="#working-with-promises-in-javascript">Working with Promises in JavaScript</a></h3>
<p>Let's work through an example - fetching a resource from a server via HTTP.
The HTTP protocol will be discussed in more detail later, but basically it enables us to send a request to a server and get a response.
Since network packets don't arrive immediately, this can take a while, so we are dealing with a &quot;long-running operation&quot;.</p>
<p>Both the browser as well as Node.js allow us to retrieve a resource from the network via the asynchronous <code>fetch</code> function.
Consider this example:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url).then((response) =&gt; console.log(response));
</code></pre>
<p>This will log the response object we get from <code>https://jsonplaceholder.typicode.com/todos/1</code> to the console (we will learn how to deal with this response object in a second).</p>
<p>We can rewrite the above example in a more explicit manner:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
fetchPromise.then((response) =&gt; console.log(response));
console.log(fetchPromise);
</code></pre>
<p>This is what happens:</p>
<ol>
<li>We call <code>fetch</code> which <em>immediately</em> returns a <em>pending</em> promise.</li>
<li>We pass a handler function into the <code>then</code> method.
The handler function will be called when the <code>fetch</code> succeeds (i.e. the promise returned by <code>fetch</code> is fulfilled).</li>
<li>After a while the <code>fetch</code> succeeds, <code>fetchPromise</code> is fulfilled and the <code>response</code> object is logged.</li>
</ol>
<p>Note that because <code>fetch</code> returns immediately <code>console.log(fetchPromise)</code> is executed before <code>console.log(response)</code>.
This is why you see the following output in your console:</p>
<pre><code>Promise { &lt;pending&gt; }
Response {
    ...
}
</code></pre>
<p>On one hand this is what we want - while we are waiting for the network request to complete, we can do other stuff (like logging <code>fetchPromise</code>).</p>
<p>On the other hand this is the reason why asynchronous programming is often so confusing to beginners - it &quot;breaks&quot; the regular programming model.
When we write synchronous code, we just execute statements one after another.
With asynchronous code this is no longer the case - here we &quot;register&quot; a function to be executed later, do something else, and then at some point the registered function is executed.</p>
<blockquote>
<p>You should pause and think about this for a second.
If you understand this point, you (mostly) understand asynchronous programming.</p>
</blockquote>
<h3 id="chaining-promises"><a class="header" href="#chaining-promises">Chaining Promises</a></h3>
<p>The <code>response</code> object is not terribly useful.
Let's retrieve the &quot;actual&quot; response which is a JSON object.
JSON is a data format for data exchange (e.g. on a network) and can basically store arbitrary JavaScript objects.
Here is how the JSON we get from <code>https://jsonplaceholder.typicode.com/todos/1</code> looks like:</p>
<pre><code class="language-json">{
  &quot;userId&quot;: 1,
  &quot;id&quot;: 1,
  &quot;title&quot;: &quot;delectus aut autem&quot;,
  &quot;completed&quot;: false
}
</code></pre>
<p>The <code>response</code> object has a <code>json</code> method to retrieve the JSON contained in a response.
However, the <code>json</code> method is also asynchronous, so we are again dealing with promises.</p>
<p>Your first instinct would be to write something like this:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
const jsonPromise = fetchPromise.then((response) =&gt; {
  const jsonPromise = response.json();
  jsonPromise.then((json) =&gt; console.log(json));
});
</code></pre>
<p>This is <em>technically</em> not wrong, but it's ugly.
Basically every time we need to add an asynchronous operation to our code that depends on the result of a previous asynchronous operation, we would need to add one level of nesting which will quickly become unreadable.</p>
<p>Luckily for us, the benevolent god-emperors of JavaScript have eliminated this problem by making <code>then</code> returns a promise that &quot;resolves&quot; to the result of the handler function.
Therefore instead of nesting promises, we can <strong>chain</strong> promises:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
const jsonPromise = fetchPromise.then((response) =&gt; response.json());
jsonPromise.then((json) =&gt; console.log(json));
</code></pre>
<p>This is called <strong>promise chaining</strong>.</p>
<p>We can rewrite this to be a bit more elegant:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; response.json())
  .then((json) =&gt; console.log(json));
</code></pre>
<h3 id="handling-errors"><a class="header" href="#handling-errors">Handling Errors</a></h3>
<p>The above code is missing error handling.
Most long-running operations (especially those that involve external resources like a network or a file system) can fail.
For example <code>fetch</code> can fail if your network is down.</p>
<p>You can turn off your network and execute the above code again.
You will get a weird error that looks approximately like this:</p>
<pre><code>TypeError: fetch failed
    at Object.fetch (node:internal/deps/undici/undici:11457:11)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5) {
  cause: Error: getaddrinfo EAI_AGAIN jsonplaceholder.typicode.com
      at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:107:26) {
    errno: -3001,
    code: 'EAI_AGAIN',
    syscall: 'getaddrinfo',
    hostname: 'jsonplaceholder.typicode.com'
  }
}
</code></pre>
<p>Additionally, we will usually want to throw an error if <code>fetch</code> itself succeeds, but the status of the response is &quot;not ok&quot; (we will return to this in more detail in the section about HTTP):</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response.json();
  })
  .then((json) =&gt; console.log(json));
</code></pre>
<p>We want to be able to catch all the errors that can happen and log an error message to the console.
The Promise API gives us the appropriately named <code>catch</code> method to accomplish this.
We simply add a catch handler to the end of our promise chain - it will be called when any of the asynchronous operations fail:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response.json();
  })
  .then((json) =&gt; console.log(json))
  .catch((error) =&gt; console.error(error));
</code></pre>
<p>Turn off your network and try running the <code>fetch</code> again.
You will now see an appropriately logged error.
Instead of just crashing, you program can now do something else (like showing an error modal to the user and informing him that something went wrong).</p>
<h3 id="async-and-await"><a class="header" href="#async-and-await">Async and Await</a></h3>
<p>Promises are great, but as discussed, the are not completely intuitive.
We can use <code>async</code> and <code>await</code> keywords to simplify asynchronous code and make it look more like synchronous code.
To this end, we can declare an <code>async</code> function and then use the <code>await</code> keyword to wait for a promise and get its fulfillment value:</p>
<pre><code class="language-js">async function fetchTask(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    const json = await response.json();
    return json;
  } catch (error) {
    console.error(`Could not fetch URL ${url}`);
  }
}

const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetchTask(url).then((json) =&gt; console.log(json));
</code></pre>
<p>Note that for some runtimes you can only use <code>await</code> inside an <code>async</code> function.
This is why we use <code>then</code> with <code>fetchTask</code> instead of <code>await</code>ing the promise returned by <code>fetchTask</code>.</p>
<h3 id="summary-6"><a class="header" href="#summary-6">Summary</a></h3>
<p>You learned about asynchronous programming.
You learned how to create promises, chain promises, handle errors in promise chains and how to simplify asynchronous code by using the async and await keywords.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<div style="text-align: right"> <i> He who writes with clarity, simplicity, and purpose will find his modules cherished by many. <br> — Ancient Chinese proverb </i> </div>
<h3 id="module-system"><a class="header" href="#module-system">Module System</a></h3>
<p>At the moment, the scripts we write are not large and easily fit into a single file.
However, as we begin writing our task application, we will run into the problem that if we try to fit our project into a single file, that script will quickly become unreadable and unmaintainable.</p>
<p>Additionally, we might often want to use third-party libraries (i.e. libraries written by someone else) in our project.
Copy and pasting the code from a third-party library seems like an obviously bad idea.
First, this would make our scripts even less readable.
Second, what do we do if the library receives an update?</p>
<p>Luckily, JavaScript provides us with a mechanism to use code from one file in another file - <strong>modules</strong>.</p>
<blockquote>
<p>Note that we will only discuss ECMAScript modules.
There are other module systems, but we won't cover them right now.</p>
</blockquote>
<h3 id="the-import-and-export-keywords"><a class="header" href="#the-import-and-export-keywords">The Import and Export Keywords</a></h3>
<p>Let's start our module discussion with a very simple example.
We will create a file containing a function and then try to use that function in another file.</p>
<p>Create a file <code>greeter.js</code> containing the following code:</p>
<pre><code class="language-js">export function greet(name) {
  return `Hello, ${name}`;
}
</code></pre>
<p>Note the <code>export</code> keyword here.
This <strong>exports</strong> the <code>greet</code> function, i.e. it tells JavaScript to make this function available to other files.</p>
<p>We can now <strong>import</strong> the <code>greet</code> function in another file.
Create a file <code>main.js</code> in which we try to use the <code>greet</code> function:</p>
<pre><code class="language-js">import { greet } from './greeter.js';

console.log(greet('John Doe'));
</code></pre>
<p>This is the basic setup, but in order to execute this in the browser or in Node.js we need to make some more adjustments.</p>
<h3 id="esm-in-the-browser"><a class="header" href="#esm-in-the-browser">ESM in the Browser</a></h3>
<p>Let's create a file named <code>index.html</code> in which we use <code>main.js</code> as a JavaScript module:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;ESM Demo&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>If you just try to open <code>index.html</code> in the browser you will a CORS Error:</p>
<pre><code>Access to script at 'file:///.../main.js' from origin 'null' has been blocked by
CORS policy: Cross origin requests are only supported for protocol schemes:
http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.
</code></pre>
<p>We will dive into CORS later, but basically this error happens because ECMAScript modules are subject to the same-origin policy.
We therefore need to serve our files over a server instead of just trying to open them in our browser.</p>
<p>Let's install the <code>http-server</code> package:</p>
<pre><code class="language-sh">npm install -g http-server
</code></pre>
<p>Now enter the directory where you stored <code>index.html</code>, <code>main.js</code> and <code>greeter.js</code> and execute the following command:</p>
<pre><code class="language-sh">http-server .
</code></pre>
<p>Go to <code>http://localhost:8080</code>, open the console and you should see <code>Hello, John Doe</code> in your console.</p>
<h3 id="esm-in-nodejs"><a class="header" href="#esm-in-nodejs">ESM in Node.js</a></h3>
<p>To use <code>main.js</code> and <code>greeter.js</code> in Node.js create the following <code>package.json</code> file:</p>
<pre><code>{
  &quot;name&quot;: &quot;projectname&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;type&quot;: &quot;module&quot;
}
</code></pre>
<p>Now you can execute <code>main.js</code> by running:</p>
<pre><code class="language-sh">node main.js
</code></pre>
<h3 id="named-exports-and-imports"><a class="header" href="#named-exports-and-imports">Named Exports and Imports</a></h3>
<p>The example above showcased the use of <strong>named exports</strong>.
Here each function is referred by its name when exporting and the same name is used when importing.
You can export multiple functions when performing named exports.</p>
<p>You can create a named export by prefixing a function with the <code>export</code> keyword:</p>
<pre><code class="language-js">export function getGreeting(name) {
  return `Hello ${name}`;
}

export function greet(name) {
  return `Hello ${name}`;
}
</code></pre>
<p>Alternatively you can use an <strong>export list</strong>:</p>
<pre><code class="language-js">function getGreeting(name) {
  return `Hello ${name}`;
}

function greet(name) {
  console.log(getGreeting(name));
}

export { getGreeting, greet };
</code></pre>
<blockquote>
<p>You should use named exports if you need to export several values.</p>
</blockquote>
<p>Note that you can rename exports in an export list:</p>
<pre><code class="language-js">function getImportantGreeting(name) {
  return `Hello ${name}!`;
}

export { greet as sayHello };
</code></pre>
<p>If you need to import multiple functions, you can do that as well:</p>
<pre><code class="language-js">import { getGreeting, greet } from './greet.js';
</code></pre>
<p>You can also rename on imports:</p>
<pre><code class="language-js">import { getGreeting, greet as sayHello } from './greet.js';
</code></pre>
<p>This is useful if you have several modules that export functions with a same name.
For example if you had a module <code>greet</code> that exports the function <code>greet</code> and a module <code>other-greet</code> that exports the function <code>greet</code> as well, you would run into problems if you just tried to import <code>greet</code>:</p>
<pre><code class="language-js">import { greet } from './greet.js';
import { greet } from './other-greet.js';
</code></pre>
<p>Instead you could rename one or both greet functions:</p>
<pre><code class="language-js">import { greet } from './greet.js';
import { greet as otherGreet } from './other-greet.js';
</code></pre>
<h3 id="default-exports-and-imports"><a class="header" href="#default-exports-and-imports">Default Exports and Imports</a></h3>
<p>If you want to have a default function provided by your module, you can use a <strong>default export</strong>:</p>
<pre><code class="language-js">export default getGreeting;
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-js">export { getGreeting as default };
</code></pre>
<p>Note that you can't have more than one default export.</p>
<p>You import the default export like this:</p>
<pre><code class="language-js">import getGreeting from './greet.js';
</code></pre>
<p>Alternatively you could use <code>default as</code>:</p>
<pre><code class="language-js">import { default as getGreeting } from './greet.js';
</code></pre>
<p>Note that you can import the default export under any name:</p>
<pre><code class="language-js">import thingy from './greet.js';
</code></pre>
<h3 id="namespace-imports"><a class="header" href="#namespace-imports">Namespace Imports</a></h3>
<p>If you wish to avoid name conflicts (like the <code>greet</code> situation presented above) you can do even better with namespace imports:</p>
<pre><code class="language-js">import * as greet from './greet.js';

greet.getGreeting('Hello');
</code></pre>
<p>The <code>import * as</code> syntax retrieves all exports available in <code>greet.js</code>, creates a <strong>namespace object</strong> <code>greet</code> and makes all the exports available as a member of that object.
This means that the <code>greet</code> conflict can be resolved like this:</p>
<pre><code class="language-js">import * as greetModule from './greet.js';
import * as otherGreetModule from './other-greet.js';

greetModule.greet('John');
otherGreeetModule.greet('John');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-leveling-up-with-typescript"><a class="header" href="#chapter-2-leveling-up-with-typescript">Chapter 2: Leveling Up with TypeScript</a></h1>
<div style="text-align: right"> <i> To employ TypeScript is to light a lantern on the dim path of JavaScript, revealing the stones upon which one may trip. <br> - Ancient Chinese proverb </i> </div>
<p>Now that we learned the basics of JavaScript, we could theoretically dive right into writing our application.
However, JavaScript as a language has a central problem - it does not come with type checking.
For example, there is nothing preventing you from trying to add two objects except the fact that you will get a runtime error.</p>
<p>We would like to be able to see this during development.
Enter TypeScript which allows us to annotate our objects and functions.
If we make a mistake, we will see it immediately.</p>
<p>The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-typescript"><a class="header" href="#why-typescript">Why TypeScript?</a></h2>
<div style="text-align: right"> <i> Better to wrangle with TypeScript's compiler today, than to wrestle with JavaScript bugs tomorrow. <br> - Ancient Chinese proverb </i> </div>
<h3 id="a-little-story"><a class="header" href="#a-little-story">A Little Story</a></h3>
<p>Consider the following scenario.
You have a JavaScript function <code>showTask(task)</code> which takes a <code>task</code> object and displays the task in a UI (or in the console).
Whenever you want to use this function you need to find out if the object you are dealing with can be passed to the function.</p>
<p>Let's say you have the following task object:</p>
<pre><code class="language-js">const task = {
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>Can you pass this object to <code>showTask</code>?
Well, you can't tell because maybe the <code>showTask</code> function expects an object that has <code>id</code>, <code>summary</code>, <code>description</code> <em>and</em> <code>status</code> fields.
The only way to find out if your <code>task</code> object is a valid input for <code>showTask</code> is to - well - actually pass it and find out.
This is obviously not the ideal workflow (especially if you happen to find out that your object lacked some important properties <em>in production</em>).</p>
<p>Additionally, if the author of the <code>showTask</code> function changes his function to expect additional properties on the <code>task</code> object, he would now have to check all the invocations of <code>showTask</code> to verify that he didn't accidentally break something.</p>
<p>This is where TypeScript comes in.
With TypeScript we would be able to <em>statically type</em> the function by adding <em>type annotations</em> like so:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  summary: string;
  description: string;
};

function showTask(task: Task) {
  // Implementation here
}
</code></pre>
<p>Now we know <em>exactly</em> what kind of object <code>showTask</code> expects.
If we pass an object that lacks some of the expected properties and run <em>type checks</em> (more on that later) we will get an error long before the bad code can make it anywhere near production.
Even better - your editor will be able to show you that you might have a problem during development:</p>
<pre><code class="language-ts">showTask({
  id: 1,
  summary: 'Read the Next.js book',
});
// Most editors will now show a squiggly red line somewhere around here and inform you that you
// that the object is missing a description property.
</code></pre>
<p>Better still, you now get <em>autocompletion</em> - editors will show possible suggestions for the property names your object should have while you type.
This saves an enormous amount of time and effort when writing code.</p>
<p>To summarize, using TypeScript massively enhances your developer workflow which is why nowadays most large projects no longer use vanilla JavaScript, but TypeScript instead.</p>
<h3 id="installing-typescript"><a class="header" href="#installing-typescript">Installing TypeScript</a></h3>
<p>Install TypeScript by running the following command:</p>
<pre><code class="language-sh">npm install -g typescript
</code></pre>
<p>This installs the TypeScript compiler <code>tsc</code> - the <code>-g</code> flag tells <code>npm</code> to install it globally.</p>
<p>Let's see how we can use it - create a file <code>index.ts</code>:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  summary: string;
  description: string;
};

function showTask(task: Task) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}

showTask({
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
});
</code></pre>
<p>We can't execute TypeScript files in the browser or in Node.js directly.
Instead we need to first <em>compile</em> the TypeScript code to JavaScript and then run the resulting JavaScript code.
Here is how we can compile the <code>index.ts</code> file:</p>
<pre><code class="language-sh">tsc index.ts
</code></pre>
<p>Since there were no type errors, nothing is logged on the console and we get a file <code>index.js</code> which looks (approximately) as follows:</p>
<pre><code class="language-js">function showTask(task) {
  console.log(
    'Task with ID='
      .concat(task.id, ' has the summary ')
      .concat(task.summary, ' and description ')
      .concat(task.description),
  );
}
showTask({
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
});
</code></pre>
<p>Note that all the type annotations are gone and all we get is vanilla JavaScript that we can execute.
Additionally the TypeScript compiler <em>downleved</em> our code so that it can be executed by older platforms.
Here the template string syntax (which is not supported by very old browser) was replaced by a series of <code>concat</code> calls.</p>
<p>What if there is an error in <code>index.ts</code>?</p>
<pre><code class="language-ts">type Task = {
  id: number;
  summary: string;
  description: string;
};

function showTask(task: Task) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}

showTask({
  id: 1,
  summary: 'Read the Next.js book',
});
</code></pre>
<p>Now we get an error if we try to run <code>tsc index.ts</code>:</p>
<pre><code>index.ts:13:10 - error TS2345: Argument of type '{ id: number; summary: string; }' is not assignable to parameter of type 'Task'.
  Property 'description' is missing in type '{ id: number; summary: string; }' but required in type 'Task'.
13 showTask({
            ~
14   id: 1,
   ~~~~~~~~
15   summary: 'Read the Next.js book',
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
16 });
   ~
  index.ts:4:3
    4   description: string;
        ~~~~~~~~~~~
    'description' is declared here.
Found 1 error in index.ts:13
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<div style="text-align: right"> <i> Use TypeScript, find enlightenment. Ignore TypeScript, trip over undefined. <br> - Ancient Chinese proverb </i> </div>
<h3 id="annotating-variables"><a class="header" href="#annotating-variables">Annotating Variables</a></h3>
<p>You can annotate variables by adding a type annotation:</p>
<pre><code class="language-ts">let task: string = 'Read the Next.js book';
</code></pre>
<p>You can annotate constants in a similar fashion:</p>
<pre><code class="language-ts">const name: string = 'Read the Next.js book';
</code></pre>
<p>Note that this usually is not needed, since TypeScript can automatically perform <em>type inference</em> and infer the type of a variable or a constant:</p>
<pre><code class="language-ts">let name = 'Read the Next.js book';
</code></pre>
<p>We will very rarely write explicit type annotations (only if we really need them) and instead let TypeScript infer as much as it can.
You be suprised by how few type annotations you need to get completely type checked code!</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<p>The primitive types that are present in TypeScript should already be familiar to you from the chapter on JavaScript.
TypeScript has the <code>number</code> type:</p>
<pre><code class="language-ts">const id: number = 1;
</code></pre>
<p>TypeScript also has the <code>string</code> type:</p>
<pre><code class="language-ts">const task: string = 'Read the Next.js book';
</code></pre>
<p>Additionally TypeScript has the <code>null</code> and <code>undefined</code> types:</p>
<pre><code class="language-ts">const undefinedTask: undefined = undefined;
const nullTask: null = null;
</code></pre>
<p>Remember that in a real codebase we would let TypeScript infer the variables:</p>
<pre><code class="language-ts">const id = 1;
const task = 'Read the Next.js book';
const undefinedTask = undefined;
const nullTask = null;
</code></pre>
<h3 id="the-any-and-unknown-types"><a class="header" href="#the-any-and-unknown-types">The Any and Unknown Types</a></h3>
<p>TypeScript also has the <code>any</code> type.
When a value is of &quot;any&quot; type, you can access its properties, call it, or assign it freely, and basically do anything (get it?) that's syntactically correct.</p>
<p>Let's say you have a <code>task</code> variable of type <code>any</code> - then these are all legal:</p>
<pre><code class="language-ts">console.log(task.summary);
task();
const otherTask = task;
</code></pre>
<p>Basically <code>any</code> is way to tell the compiler to &quot;shut up&quot; and skip type checking.
This is also the reason why using <code>any</code> is generally a terrible idea since it defeats the purpose of using TypeScript in the first place!</p>
<p>However sometimes you do find yourself in a situation where you don't know much about a variable type.
In this case it's better to use <code>unknown</code>.
If you have a <code>task</code> variable of type <code>unknown</code>, then these are all no longer legal:</p>
<pre><code class="language-ts">console.log(task.summary);
task();
const otherTask = task;
</code></pre>
<h3 id="typing-arrays"><a class="header" href="#typing-arrays">Typing Arrays</a></h3>
<p>You can type arrays as <code>T[]</code> where <code>T</code> is the type of the elements of the array.
For example here is how you could type an array of numbers:</p>
<pre><code class="language-ts">const evenNumbers: number[] = [1, 2, 3, 4];
</code></pre>
<p>Here is how you would an array of strings:</p>
<pre><code class="language-ts">const tasks: string[] = ['First task', 'Second task', 'Third task'];
</code></pre>
<p>Note that for these simple example we could again infer the types.</p>
<h3 id="typing-objects"><a class="header" href="#typing-objects">Typing Objects</a></h3>
<p>You can type an object by writing the property names and types of its properties inside curly braces <code>{}</code>.
For example here how you could declare an object that has the properties <code>id</code> of type <code>number</code>, <code>summary</code> of type <code>string</code> and <code>description</code> of type <code>string</code>:</p>
<pre><code class="language-ts">const task: { id: number; summary: string; description: string } = {
  id: 1,
  summary: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>You can mark properties as <em>optional</em> by using the question mark <code>?</code>.
If a property is marked as optional, you don't need to specify it.
For example this is valid:</p>
<pre><code class="language-ts">const task: { id: number; summary: string; description?: string } = {
  id: 1,
  summary: 'Read the Next.js book',
};
</code></pre>
<h3 id="type-alias"><a class="header" href="#type-alias">Type Alias</a></h3>
<p>The object syntax we just introduced is not particulary readable.
This is why TypeScript gives you the possibility to specify a <strong>type alias</strong> (i.e. another name) for an object type:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  summary: string;
  description: string;
};
</code></pre>
<p>Note that you can specify type aliases for more than just object types sind type aliases are basically just different names for types.
For example we could specify a type alias for the primitive type <code>string</code>:</p>
<pre><code class="language-ts">type ID = string;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="annotating-functions"><a class="header" href="#annotating-functions">Annotating Functions</a></h2>
<div style="text-align: right"> <i> The function without types is like a river without banks: boundless, yet directionless. <br> - Ancient Chinese proverb </i> </div>
<h3 id="annotating-parameters"><a class="header" href="#annotating-parameters">Annotating Parameters</a></h3>
<p>We can annotate functions in TypeScript by annotating their parameters.
Consider a function <code>greet</code> that takes a parameter <code>name</code> of type <code>string</code> and simply logs a greeting to the console.
Here is how we would annotate the function:</p>
<pre><code class="language-ts">function greet(name: string) {
  console.log(`Hello, ${name}`);
}
</code></pre>
<p>Now arguments to the function are checked:</p>
<pre><code class="language-ts">greet(false);
// This will result in an error
</code></pre>
<p>You can also annotate functions if they take array and object by simply using the syntax you learned in the previous section:</p>
<pre><code class="language-ts">function showTask(task: { id: number; summary: string; description: string }) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}
</code></pre>
<p>This is not particularly readable, so normally we would use a type alias:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  summary: string;
  description: string;
};

function showTask(task: Task) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}
</code></pre>
<p>Note that TypeScript will not just check that the passed arguments have the correct types, but also check that the correct number of argument was passed.
This has an interesting side effect - namely that introducing the TypeScript compiler in a JavaScript codebase can already find potential bugs:</p>
<pre><code class="language-js">function showTask(task) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}

// Uh-oh, we are passing multiple variables instead of a single object!
showTask(1, 'Read the Next.js book', 'Read and understand the Next.js book.');
</code></pre>
<p>If we run <code>tsc</code> on this code, we will get the following error:</p>
<pre><code>index.ts:8:13 - error TS2554: Expected 1 arguments, but got 3.

8 showTask(1, 'Read the Next.js book', 'Read and understand the Next.js book.');
</code></pre>
<p>TypeScript is useful indeed!</p>
<h3 id="return-type-annotations"><a class="header" href="#return-type-annotations">Return Type Annotations</a></h3>
<p>We can also type the return types of our functions:</p>
<pre><code class="language-ts">function getGreeting(name: string): string {
  return `Hello, ${name}`;
}
</code></pre>
<p>Note that you usually don't need a return type annotation because TypeScript can do type inference for them:</p>
<pre><code class="language-ts">function getGreeting(name: string) {
  return `Hello, ${name}`;
}
</code></pre>
<p>Nevertheless, return types are often typed explicitly to avoid accidentally returning a type you didn't want to return or to prevent accidental changes to the return type.</p>
<h3 id="optional-parameters"><a class="header" href="#optional-parameters">Optional Parameters</a></h3>
<p>Similar to object properties, function parameters can be marked as <em>optional</em>.
In this case we can, but don't need to pass the corresponding argument to the function:</p>
<pre><code class="language-ts">function getGreeting(name: string, message?: string): string {
  return `${message !== undefined ? message : 'Hello'}, ${name}`;
}

// These are both valid
getGreeting('John Doe', 'Welcome');
getGreeting('John Doe');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="union-types"><a class="header" href="#union-types">Union Types</a></h2>
<h3 id="literal-types"><a class="header" href="#literal-types">Literal Types</a></h3>
<p>A literal type is a type whose only value is a literal.
Here is how we could define a literal type <code>&quot;Todo&quot;</code>:</p>
<pre><code class="language-ts">type TodoType = 'Todo';
</code></pre>
<p>Here is how we can use it:</p>
<pre><code class="language-ts">let todo: TodoType = 'Todo';
</code></pre>
<p>Note that we can't assign any other value to <code>todo</code> including other strings.
For example this is not possible:</p>
<pre><code class="language-ts">let todo: TodoType = 'Done';
</code></pre>
<p>We could also skip declaring the type alias and just use the literal type directly:</p>
<pre><code class="language-ts">let todo: 'Todo' = 'Todo';
</code></pre>
<p>While literal types by themselves are not very useful, they are extremely useful in the context of union types.</p>
<h3 id="unions-of-literal-types"><a class="header" href="#unions-of-literal-types">Unions of Literal Types</a></h3>
<p>A union type is a type that represents a value which may be one of multiple values.
Consider the type <code>TaskState</code> which represents one of the following states:</p>
<ul>
<li>Todo</li>
<li>InProgress</li>
<li>Done</li>
</ul>
<p>Here is how we would defined the <code>TaskState</code> type:</p>
<pre><code class="language-ts">type TaskState = 'Todo' | 'InProgress' | 'Done';
</code></pre>
<p>The <code>TaskState</code> type is a union type and each of the literal types <code>'Todo'</code>, <code>'InProgress'</code> and <code>'Done'</code> is a member of the union.
A variable of type <code>TaskState</code> can only be of one of these literal types, i.e. it can only have one of the respective values.
For example these are all valid:</p>
<pre><code class="language-ts">const state: TaskState = 'Todo';
const state2: TaskState = 'InProgress';
const state3: TaskState = 'Done';
</code></pre>
<p>But this is not:</p>
<pre><code class="language-ts">const invalidState: TaskState = 'Dropped';
</code></pre>
<h3 id="other-union-types"><a class="header" href="#other-union-types">Other Union Types</a></h3>
<p>We can also declare unions of arbitrary types.
One particulary useful union type is <code>T | undefined</code>, for example:</p>
<pre><code class="language-ts">function getTaskId(taskName: string): string | undefined {
  // Implementation here
}
</code></pre>
<p>This function takes a <code>taskName</code> and returns the corresponding ID.
However since it might be the case that no task with the given name is present, we return either a <code>string</code> or <code>undefined</code>.</p>
<h3 id="working-with-a-union-type"><a class="header" href="#working-with-a-union-type">Working with a Union Type</a></h3>
<p>It's relatively clear how to define a union type, but how can we work with a union type?
Consider the following function:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined) {
  console.log({
    taskName,
    taskNameLength: taskName.length,
  });
}
</code></pre>
<p>This will result in the following error:</p>
<pre><code>index.ts:4:21 - error TS18048: 'taskName' is possibly 'undefined'.
4     taskNameLength: taskName.length,
                      ~~~~~~~~
Found 1 error in index.ts:4
</code></pre>
<p>TypeScript will only allow to do something with the value of a union type if that something is valid for every member of the union.
Since <code>taskName</code> can be either a <code>string</code> or <code>undefined</code>, we can't call <code>.length</code> on it!</p>
<p>Instead we need to <em>narrow</em> the type:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined) {
  if (taskName !== undefined) {
    console.log({
      taskName,
      taskNameLength: taskName.length,
    });
  } else {
    console.log('the task is not defined');
  }
}
</code></pre>
<p>We narrow the type of <code>taskName</code> in the <code>taskName !== undefined</code> branch.
TypeScript can inspect the control flow and realize that since <code>taskName</code> had the <code>string | undefined</code> type and <code>taskName !== undefined</code> in the truthy branch of the if statement, <code>taskName</code> must be of type <code>string</code> inside that branch.</p>
<p>Narrowing can be done by using <code>typeof</code>, checking truthiness of values or with equality checks <code>x === y</code>.</p>
<h3 id="discriminated-unions"><a class="header" href="#discriminated-unions">Discriminated Unions</a></h3>
<p>A particularly important union type is the <strong>discriminated union</strong>.
This is a union where a property is used to discriminate between union members.
Consider the following classical example:</p>
<pre><code class="language-ts">type Square = {
  kind: 'square';
  size: number;
};

type Rectangle = {
  kind: 'rectangle';
  width: number;
  height: number;
};

type Shape = Square | Rectangle;
</code></pre>
<p>We can now narrow values of the discriminated union based on the <strong>discriminant property</strong> (which in this case is <code>kind</code>):</p>
<pre><code class="language-ts">function getArea(shape: Shape) {
  if (shape.kind === 'square') {
    return shape.size * shape.size;
  } else {
    return shape.width * shape.height;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<div style="text-align: right"> <i> Generics are the invisible hat of the TypeScript sage, fitting the heads of both the giant and the dwarf. <br> - Ancient Chinese proverb </i> </div>
<h3 id="why-generics"><a class="header" href="#why-generics">Why Generics?</a></h3>
<p>Generics allow us to write code that is independent of specific types.
Consider the example of retrieving the first element of an array:</p>
<pre><code class="language-js">function getFirstElement(arr) {
  return arr[0];
}
</code></pre>
<p>How would we type this?
We could use <code>any</code>:</p>
<pre><code class="language-ts">function getFirstElement(arr: any): any {
  return arr[0];
}
</code></pre>
<p>However using <code>any</code> is bad since we lose all the type information even if we pass in an array of a known type.</p>
<p>We could also make use of <em>function overloads</em> and write something like this:</p>
<pre><code class="language-ts">function getFirstElement(arr: number[]): number;
function getFirstElement(arr: string[]): string;
function getFirstElement(arr: undefined[]): undefined;
// More overloads and implementation here
</code></pre>
<p>But this obviously gets very tedious and error-prone the more we do it.
Instead TypeScript allows us to use <em>generics</em> to specify that we don't really care about a type.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Consider the identity function that simply takes an argument <code>arg</code> and returns it unchanged.
We can use a type variable <code>Type</code> and type it like this:</p>
<pre><code class="language-ts">function identity&lt;Type&gt;(arg: Type): Type {
  return arg;
}
</code></pre>
<p>This basically says that the <code>identity</code> function takes an argument of type <code>Type</code> and that its return type is of the same type as the argument.
Now we get proper type inference:</p>
<pre><code class="language-ts">let val = 'Hello, world!';
let val2 = identity&lt;string&gt;(val); // val2 is of type string
</code></pre>
<p>We dont actually have to manually specify the type <code>string</code> when calling the function and can instead rely on TypeScripts inference:</p>
<pre><code class="language-ts">let val = 'Hello, world!';
let val2 = identity(val); // val2 is of type string
</code></pre>
<blockquote>
<p>There is no single convention for naming type parameters.
Common names includew <code>T</code>, <code>Type</code> and <code>TType</code>.</p>
</blockquote>
<h3 id="generic-object-types"><a class="header" href="#generic-object-types">Generic Object Types</a></h3>
<p>Just like with functions, we can use type parameters with objects:</p>
<pre><code class="language-ts">type Box&lt;Type&gt; = {
  content: Type;
};
</code></pre>
<p>Now we can use the <code>Box</code> type with any type:</p>
<pre><code class="language-ts">// box has the type Box&lt;number&gt;
const box = {
  content: 0,
};

// box2 has the type Box&lt;string&gt;
const box2 = {
  content: 'Hello, world!',
};
</code></pre>
<h3 id="important-builtin-generics"><a class="header" href="#important-builtin-generics">Important Builtin Generics</a></h3>
<p>Generic object types can function as versatile containers, unaffected by the specific types of items they hold.
Such flexibility in data structures is preferred, allowing them to be applied across various data kinds.</p>
<p>Examples of generic object types are:</p>
<ul>
<li><code>Array&lt;Type&gt;</code></li>
<li><code>Map&lt;Key, Value&gt;</code></li>
<li><code>Set&lt;Type&gt;</code></li>
<li><code>Record&lt;Key, Value&gt;</code></li>
</ul>
<p>One other very important generic type is the <code>Promise</code> type which can be used to annotate asynchronous functions.
For example, if we have an asynchronous function <code>f</code> that returns a promise with a string, we would annotate it like this:</p>
<pre><code class="language-ts">async function f(): Promise&lt;string&gt; {
  // Implementation here
}
</code></pre>
<h3 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h3>
<p>Often, we don't want to pass <em>completely arbitrary</em> type parameters.
For example we might want to ensure that the variable we pass has the <code>length</code> property.
We can't just use it though, since this will lead to an error.
Consider this example:</p>
<pre><code class="language-ts">function printLength&lt;Type&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<p>This will throw the following error:</p>
<pre><code>index.ts:2:14 - error TS2339: Property 'length' does not exist on type 'Type'.
2   return arg.length;
               ~~~~~~
Found 1 error in index.ts:2
</code></pre>
<p>This makes sense since <code>arg</code> can be of literally any type and there is no guarantee that <code>arg</code> will actually have the property <code>length</code>.
To change this, we need to constrain the type <code>Type</code>:</p>
<pre><code class="language-ts">function printLength&lt;Type extends { length: number }&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<p>As usual, we can use a type alias here:</p>
<pre><code class="language-ts">type HasLength = {
  length: number;
};

function printLength&lt;Type extends HasLength&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-keyof-and-typeof-type-operators"><a class="header" href="#the-keyof-and-typeof-type-operators">The keyof and typeof Type Operators</a></h2>
<div style="text-align: right"> <i> He who understands the keyof can unlock the mysteries of the object, and with typeof, discern its essence. <br> - Ancient Chinese proverb </i> </div>
<h3 id="the-keyof-type-operator"><a class="header" href="#the-keyof-type-operator">The keyof Type Operator</a></h3>
<p>The <code>keyof</code> type operator takes an object type and produces a literal union of its keys.
For example:</p>
<pre><code class="language-ts">type User = { name: string; email: string; age: number };
type UserKeys = keyof User;

// UserKeys is equivalent to &quot;name&quot; | &quot;email&quot; | &quot;age&quot;
</code></pre>
<p>The <code>keyof</code> type operator is particularly useful with generics.
Consider the following example:</p>
<pre><code class="language-ts">function getProperty&lt;Type, Key&gt;(obj: Type, key: Key) {
  return obj[key];
}
</code></pre>
<p>This will <em>not</em> compile because we have no idea if <code>key</code> can be used to index into <code>obj</code> so you will get the following error:</p>
<pre><code>index.ts:2:10 - error TS2536: Type 'Key' cannot be used to index type 'Type'.
2   return obj[key];
           ~~~~~~~~
Found 1 error in index.ts:2
</code></pre>
<p>Therefore we need to specify that <code>Key</code> should be of a type that can be used to index into an object of type <code>Type</code>.
In other words, <code>Key</code> should extend <code>keyof Type</code>:</p>
<pre><code class="language-ts">function getProperty&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) {
  return obj[key];
}
</code></pre>
<h3 id="the-typeof-type-operator"><a class="header" href="#the-typeof-type-operator">The typeof Type Operator</a></h3>
<p>The <code>typeof</code> type operator can be used to refer to the type of a variable:</p>
<pre><code class="language-ts">let str = 'Hello, world!';
let str2: typeof str; // str2 is a string
</code></pre>
<p>An example where this is useful is when you want to create a type that is equivalent to the return type of a function.
You can use the generic type <code>ReturnType&lt;T&gt;</code> - the type parameter <code>T</code> is a function type and <code>ReturnType&lt;T&gt;</code> is then the return type of the function.</p>
<p>Consider a function <code>getTask(...)</code> which returns an object of some type.
Then you could get the return type like this:</p>
<pre><code class="language-ts">type MyReturnType = ReturnType&lt;typeof getTask&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-a-vanilla-client"><a class="header" href="#chapter-3-a-vanilla-client">Chapter 3: A Vanilla Client</a></h1>
<div style="text-align: right"> <i> Whenever you write a web app in vanilla JavaScript, you end up creating your own framework. <br> And who in their right mind wants another JavaScript framework? <br> - Common programmer idiom </i> </div>
<p>In this chapter we will write a client a in <em>vanilla</em> HTML and JavaScript (i.e. without using any frameworks).
Then we will realize why this is not such a great idea and why we might want to consider using a library (spoiler: it's going to be React) to help us out.</p>
<p>If this sounds like a pointless exercise - it's not.
You need to know the basics of HTML anyway (even if you will use React for everything later).
Additionally, web development shouldn't consists of stapling a bunch of magic together and praying that it works.
In order to accomplish this, you will need a solid foundation to build on.</p>
<p>This chapter presents that solid foundation.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hypertext-markup-language"><a class="header" href="#hypertext-markup-language">Hypertext Markup Language</a></h2>
<div style="text-align: right"> <i> Hey guys, how do I parse HTML with a regular expression? <br> - Seconds before disaster </i> </div>
<h3 id="a-minimal-html-file"><a class="header" href="#a-minimal-html-file">A minimal HTML file</a></h3>
<p>Create a project directory (<em>easy-opus</em> for example).
From here on, all work will be done within the <em>easy-opus</em> directory.</p>
<p>Now, let's create a webpage using <strong>HTML</strong>, a markup language designed for defining documents to be displayed in a browser.
We briefly touched on HTML in section 1.1, but now we will look at HTML a bit more detail.</p>
<blockquote>
<p>Markup languages provide rules for defining the type of information contained in a document.
Markup languages differ from programming languages - while markup languages enable the creation of displayable documents, programming languages offer much more powerful capabilities.
Therefore HTML is a markup language and JavaScript is a programming language.</p>
</blockquote>
<p>Create a file named <code>index.html</code> in the project directory.
Now write some minimal useful HTML to display two hardcoded tasks:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Easy Opus&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;div&gt;
        &lt;h1&gt;My tasks&lt;/h1&gt;
        &lt;div id=&quot;taskList&quot;&gt;
          &lt;p&gt;Read the Next.js book&lt;/p&gt;
          &lt;p&gt;Write a website&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>When you open the HTML file in your browser you should a heading and two tasks.</p>
<p>Hooray, you've created a simple HTML document!
Now you can close this book and go procrastinate.</p>
<p>What's that?
You're not budging?
Hm, that's weird.
Oh we see, you've <em>unfortunately</em> been <em>forced</em> to read this book (blink <em>once</em> for help).</p>
<p>Well, since we both have to be here anyway, let's march onwards and dissect the masterpiece you've just created!</p>
<h3 id="html-elements"><a class="header" href="#html-elements">HTML elements</a></h3>
<p>HTML is comprised of <strong>HTML elements</strong> used to specify the type of content you want to render.
For example, the <code>p</code> element represents a paragraph:</p>
<pre><code class="language-html">&lt;p&gt;Read the Next.js book&lt;/p&gt;
</code></pre>
<p>An HTML element usually has some <strong>content</strong> between an <strong>opening tag</strong> and a <strong>closing tag</strong>.
The opening tag is the name of the element wrapped in angle brackets (like <code>&lt;p&gt;</code>).
The closing tag is the name of the element wrapped in angle brackets with a <em>forward slash before the element name</em> (like <code>&lt;/p&gt;</code>).</p>
<p>There are various HTML elements, such as <code>p</code> for paragraphs and <code>div</code> for generic containers.
We will discuss more elements later.</p>
<p>HTML's power lies in the fact that most elements can be nested.
For example, you could nest paragraphs within a generic container:</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;Read the Next.js book&lt;/p&gt;
  &lt;p&gt;Create a website&lt;/p&gt;
  &lt;p&gt;???&lt;/p&gt;
  &lt;p&gt;Profit!&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>The nesting can go as many levels as you want.
For example, we could use the <code>&lt;em&gt;</code> element to emphasize some of the words in the previous example:</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;Read the &lt;em&gt;Next.js&lt;/em&gt; book&lt;/p&gt;
  &lt;p&gt;Create a &lt;em&gt;website&lt;/em&gt;&lt;/p&gt;
  &lt;p&gt;???&lt;/p&gt;
  &lt;p&gt;Profit!&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>Note that to do nesting correctly, the tags of the element being nested must be inside the tags of the element it is being nested in.
For example the tags of the element <code>&lt;em&gt;Next.js&lt;/em&gt;</code> are inside the element <code>&lt;p&gt;Read the &lt;em&gt;Next.js&lt;/em&gt; book&lt;/p&gt;</code>.</p>
<h3 id="html-attributes"><a class="header" href="#html-attributes">HTML Attributes</a></h3>
<p>Elements can also have <strong>HTML attributes</strong>.
Attributes contain further information about the element.
Two particularly important attributes are <code>id</code> and <code>class</code>.</p>
<p>The <code>id</code> attribute is used to specify a <strong>unique identity</strong> for an HTML element.
You can use that attribute to - well - uniquely identify an element.
This allows us to reference that element using JavaScript or CSS.</p>
<p>Here is how we can create an element with an <code>id</code> attribute:</p>
<pre><code class="language-html">&lt;p id=&quot;readBook&quot;&gt;Read the Next.js book&lt;/p&gt;
</code></pre>
<p>Generally speaking, you can specify attributes by writing the attribute name, followed by an equal sign, followed by the attribute value (which is wrapped inside double quotes).</p>
<p>The <code>class</code> attribute is used to specify a <strong>class</strong> for an HTML element.
Unlike unique identifiers, multiple HTML elements can share the same class, which is useful for applying consistent styles to multiple elements.
For example you could color all HTML elements of class <code>blue-text</code> blue.</p>
<p>There are many more attributes and different HTML elements often have different attributes.</p>
<p>We will cover some of the most important elements together with their attributes in the next section.</p>
<h3 id="structure-of-an-html-document"><a class="header" href="#structure-of-an-html-document">Structure of an HTML Document</a></h3>
<p>Let's have a look at <code>index.html</code> again:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Easy Opus&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;div&gt;
        &lt;h1&gt;My tasks&lt;/h1&gt;
        &lt;div id=&quot;taskList&quot;&gt;
          &lt;p&gt;Read the Next.js book&lt;/p&gt;
          &lt;p&gt;Write a website&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The document begins with <code>&lt;!DOCTYPE html&gt;</code> which is a <em>document type declaration</em>.
It is there mainly for historical reasons - in the <em>olden days</em> of HTML the doctype specified which rules the HTML page followed.
Nowadays, we just use the shortest valid doctype which happens to be <code>&lt;!DOCTYPE html&gt;</code>.</p>
<p>The doctype is followed by an <code>&lt;html&gt;</code> element which contains all the content of the document.
This element is usually called the <strong>root element</strong>.</p>
<p>The <code>&lt;head&gt;</code> element includes important information about the page.
Here is where we could specify how our page would appear in search results, which character encoding our website uses and more.</p>
<p>In our example the <code>&lt;head&gt;</code> element includes a <code>&lt;meta&gt;</code> element with a <code>charset</code> attribute and a <code>&lt;title&gt;</code> element.
This particular <code>&lt;meta&gt;</code> element describes the character encoding for the HTML document (we will return to this later in more detail) and the <code>&lt;title&gt;</code> element sets the title of the page (i.e. the title that will appear in the browser tab).</p>
<p>Finally the <code>&lt;body&gt;</code> element contains all the content that will actually be rendered on the page.
In our example, the heading and the task list are within the <code>&lt;body&gt;</code> element.</p>
<blockquote>
<p>We will discuss character encodings in greater detail later.</p>
</blockquote>
<h3 id="summary-7"><a class="header" href="#summary-7">Summary</a></h3>
<p>You know what HTML is, how HTML elements look like and how to use HTML attributes.
You also know how the basic structure of an HTML document looks like.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="marking-up-text"><a class="header" href="#marking-up-text">Marking Up Text</a></h2>
<div style="text-align: right"> <i> Who needs semantic HTML anyway? <br> - Seconds before disaster </i> </div>
<h3 id="the-paragraph-element"><a class="header" href="#the-paragraph-element">The Paragraph Element</a></h3>
<p>The most basic element for marking up text is the paragraph element <code>&lt;p&gt;</code>:</p>
<pre><code class="language-html">&lt;p&gt;This is the first paragraph of many, many paragraphs.&lt;/p&gt;
&lt;p&gt;This is the second paragraph of many, many paragraphs.&lt;/p&gt;
&lt;p&gt;This is the third paragraph of many, many paragraphs.&lt;/p&gt;
</code></pre>
<p>Visually paragraphs are represented as text blocks separated from surrounding content by blank lines.
Paragraphs are commonly used to group related text.</p>
<h3 id="breaking-up-text"><a class="header" href="#breaking-up-text">Breaking Up Text</a></h3>
<p>You can break up text with the line break element <code>&lt;br&gt;</code>:</p>
<pre><code class="language-html">There is a line break here. &lt;br /&gt;
This is some text after the line break.
</code></pre>
<p>Additionally you can use the <code>&lt;hr&gt;</code> element for a thematic break of some text.
It will usually be visually presented as a horizontal line.</p>
<pre><code class="language-html">Here is some text. &lt;hr /&gt; Here some text about something totally different.
</code></pre>
<p>Often the <code>&lt;hr /&gt;</code> element is used to introduce thematic breaks between paragraphs.</p>
<h3 id="heading-elements"><a class="header" href="#heading-elements">Heading Elements</a></h3>
<p>There are six heading elements <code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>.
The different heading elements represent different &quot;heading levels&quot;, e.g. <code>&lt;h1&gt;</code> is the main heading, <code>&lt;h2&gt;</code> a subheading and so on:</p>
<pre><code class="language-html">&lt;h1&gt;Main heading&lt;/h1&gt;

&lt;h2&gt;Subheading 1&lt;/h2&gt;
&lt;h3&gt;Subsubheading 1.1&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 1.1&lt;/p&gt;
&lt;h3&gt;Subsubheading 1.2&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 1.2&lt;/p&gt;

&lt;h2&gt;Subheading 2&lt;/h2&gt;

&lt;h3&gt;Subsubheading 2.1&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 2.1&lt;/p&gt;
&lt;h3&gt;Subsubheading 2.2&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 2.2&lt;/p&gt;
</code></pre>
<p>You will rarely need <code>&lt;h4&gt;</code> to <code>&lt;h6&gt;</code> - very few documents require such an amount of heading levels.</p>
<blockquote>
<p>Always try to use a single <code>&lt;h1&gt;</code> per page since this is the top level heading.</p>
</blockquote>
<h3 id="emphasis-and-importance"><a class="header" href="#emphasis-and-importance">Emphasis and Importance</a></h3>
<p>If we want to emphasize a part of a text (like an important word) we can use the <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> elements.
The <code>&lt;em&gt;</code> element marks that a text should be emphasized, for example:</p>
<pre><code class="language-html">The weather today is &lt;em&gt;very&lt;/em&gt; hot.
</code></pre>
<p>The <code>&lt;strong&gt;</code> element marks that a text has strong importance, for example:</p>
<pre><code class="language-html">The weather today is not just hot, it's &lt;strong&gt;scorching&lt;/strong&gt;.
</code></pre>
<p>As you probably guessed, deciding which of these two elements is appropriate is largely on you.
If you want to emphasize some part of a text, but it doesn't have strong urgency you should use <code>&lt;em&gt;</code>.
If a text is very important, you should use <code>&lt;strong&gt;</code></p>
<blockquote>
<p>There are also <code>&lt;i&gt;</code> and <code>&lt;b&gt;</code>, however we will rarely use them, since <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> have a semantic meaning (see below for what this means).</p>
</blockquote>
<h3 id="other-text-elements"><a class="header" href="#other-text-elements">Other Text Elements</a></h3>
<p>We only scratched the surface of the kind of text markup you can perform with HTML.
There are many, many other elements you can use.
For example, you can mark up subscripts and superscripts with <code>&lt;sub&gt;</code> and <code>&lt;sup&gt;</code> respectively:</p>
<pre><code class="language-html">The chemical formula for water is H&lt;sub&gt;2&lt;/sub&gt;O.
&lt;p&gt;The equation for energy is E = mc&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;
</code></pre>
<p>You can add quotes - both blockquotes (with <code>&lt;blockquote&gt;</code>) and inline quotes (with <code>&lt;q&gt;</code>):</p>
<pre><code class="language-html">&lt;p&gt;As the famous physicist once said:&lt;/p&gt;

&lt;blockquote cite=&quot;https://some-random-quotes.com/&quot;&gt;
  &quot;Stop believing quotes you found on the internet&quot;
&lt;/blockquote&gt;

&lt;p&gt;
  As Einstein once said,
  &lt;q&gt;people who build their lifes around random internet quotes are stupid.&lt;/q&gt;
&lt;/p&gt;
</code></pre>
<p>The point here is not to learn everything single HTML element for marking up text, but to be aware that when it comes to marking up text there might be an HTML element for your usecase.</p>
<h3 id="semantic-html"><a class="header" href="#semantic-html">Semantic HTML</a></h3>
<p>In a few chapters, we will introduce you to CSS, which will allow you to style your HTML elements however you like.
At this point most people forget that there any elements besides the generic containers <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> since they can now just <em>style</em> a <code>&lt;span&gt;</code> to look like an <code>&lt;h1&gt;</code>.</p>
<p>This is bad.</p>
<p>The reason this is bad is that <em>looking</em> at a page is not the only way to browse the web.</p>
<p>First of, there are a lot of visually impaired people in the world who use screen readers to navigate the internet.
Screen readers tend to focus on the HTML elements and not the styles (which makes sense, since reading out styles is not really something you want to do).</p>
<p>If you write a heading as a styled <code>&lt;span&gt;</code> instead of an <code>&lt;h1&gt;</code> you are not only doing more (unneccessary) work, you also give visually impaired people a worse experience.
Screen readers often interpret headings in a special way - for example you can ask most screen readers to read all headings on a page out loud and then jump to some heading you care about.
This is of course not possible with <code>&lt;span&gt;</code>s.</p>
<p>Second, your page will also be consumed by programs responsible for indexing and ranking.
If your website contains generic containers only, it will usually be downgraded resulting in (shock and horror) <em>bad Search Engine Optimization</em>.</p>
<p>Therefore you should <em>absolutely not</em> forget about the <em>semantically correct</em> HTML element we presented in this section.</p>
<blockquote>
<p>Also, if you don't use semantically correct HTML, your fellow developers will let you know about this in the <em>smuggest</em> way possible which will feel bad for you.
After all, <em>you</em> want to be one smuggly telling your collegue - &quot;you know, I don't think that this is semantically correct&quot;.</p>
</blockquote>
<h3 id="summary-8"><a class="header" href="#summary-8">Summary</a></h3>
<p>You learned how to mark up text in a semantically correct way.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
